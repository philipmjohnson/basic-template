<!DOCTYPE html>
<html>
<head>
  <title> Chapter 9 Notes | ICS 311 Spring 2014 </title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="utf-8">
  <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootswatch/3.1.0/cerulean/bootstrap.min.css">

  <!--  Load site-specific customizations after bootstrap. -->
  <link rel="stylesheet" href="/ics311s14/css/style.css">
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Open+Sans:normal,italic,bold">
  <link rel="shortcut icon" href="/ics311s14/favicon.ico" type="image/x-icon" />

  <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!--[if lt IE 9]>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.2/html5shiv.js"></script>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/respond.js/1.2.0/respond.js"></script>
  <![endif]-->

  <!-- Load Bootstrap JavaScript components -->
  <script src="http://code.jquery.com/jquery.min.js"></script>
  <script src="http://netdna.bootstrapcdn.com/bootstrap/3.1.0/js/bootstrap.min.js"></script>
</head>
<body>
<!-- Responsive navbar -->
<div class="navbar navbar-default navbar-inverse navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
        <!--  Display three horizontal lines when navbar collapsed. -->
        <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="#"> ICS 311 Spring 2014 </a>
    </div>
    <div class="collapse navbar-collapse">
      <ul class="nav navbar-nav">
        <li><a href="/ics311s14/index.html">Home</a></li>
        <li><a href="/ics311s14/modules/">Modules</a></li>
        <li><a href="/ics311s14/outcomes/">Outcomes</a></li>
        <li><a href="/ics311s14/readings/">Readings</a></li>
        <li><a href="/ics311s14/experiences/">Experiences</a></li>
        <li><a href="/ics311s14/assessments/">Assessments</a></li>
        <li><a href="/ics311s14/schedule/">Schedule</a></li>
        
      </ul>
    </div>
  </div>
</div>


<div class="container">
  <h1>Heaps, Heapsort, and Priority Queues</h1>

<h2>Outline</h2>

<ol>
<li>Heaps and their Properties</li>
<li>Building and Maintaining Heaps</li>
<li>Application to Sorting</li>
<li>Application to Priority Queues</li>
</ol>

<h2>Heaps and their Properties</h2>

<p>Heaps are a useful data structure with applications to sorting and priority
queues.</p>

<p>They are <em>nearly complete binary trees</em> that satisfy a <em>heap property</em> that
organizes data under a partial ordering of their keys, enabling access to
elements with maximum (or minimum) keys without having to pay the cost of
fully sorting the keys.</p>

<p>Heaps are not to be confused with garbage collected storage (a heap of
garbage)!</p>

<h3>Heaps as Nearly Complete Binary Trees</h3>

<p>Conceptually, heaps are <strong>nearly complete binary trees</strong>: they have leaves on
at most two adjacent levels <em>l-1</em> and <em>l</em> and in which the leaves at the
bottommost level <em>l</em> lie in the leftmost positions of <em>l</em>:</p>

<p><img src="fig/Fig-6-1-max-heap-tree.jpg" alt=""></p>

<p>These quantitative properties concerning full and nearly complete binary trees
will be useful:</p>

<h4>Number of elements in nearly complete binary trees of height <em>h</em> (6.1-1)</h4>

<p><img src="fig/diagram-tree-heights-wide.jpg" alt=""></p>

<p>As discussed in <a href="http://www2.hawaii.edu/%7Esuthers/courses/ics311s14/No%0Ates/Topic-08.html#binarytrees">Topic 8</a>, a <strong>complete binary tree</strong> has at most 2<em>h</em>+1
− 1 nodes (vertices). We can see this by adding up the number of elements at
each level: 20 + 21 + ... + 2h for a complete binary tree of height <em>h</em>.
Then apply formula A.5 with <em>x</em>=2 and <em>n</em>=<em>h</em>:</p>

<p><img src="fig/formula-A-5.jpg" alt=""></p>

<p>You get (2<em>h</em>+1 − 1) / (2 − 1) = 2<em>h</em>+1 − 1.</p>

<p>So, a <em>nearly</em> complete binary tree has <em>at most</em> 2<em>h</em>+1 − 1 elements (if it
is complete, as analyzed above). The <em>fewest</em> number of elements it can have
at height <em>h</em> is when the last level has just 1 element and the level before
it is complete. So do the math for a complete binary tree of height <em>h</em>−1:
there are exactly 2<em>h</em> − 1 elements in levels 1 to <em>l</em>−1 and one more element
in the <em>l</em>th level, for a total of 2<em>h</em> elements.</p>

<h4>Height of an <em>n</em>-element nearly complete binary tree (6.1-2)</h4>

<p>Given an <em>n</em>-element nearly complete binary tree of height <em>h</em>, from 6.1-1:</p>

<blockquote>
<p>2<em>h</em>   ≤   <em>n</em>   ≤   2<em>h+1</em> − 1   &lt;   2<em>h+1</em></p>
</blockquote>

<p>Taking the log of the first, second and last terms,</p>

<blockquote>
<p><em>h</em>   ≤   lg <em>n</em>   &lt;   <em>h</em> + 1</p>
</blockquote>

<p>Since <em>h</em> is an integer, <em>h</em> = ⌊lg <em>n</em>⌋     <em>(Notice the &quot;floor&quot; notation.)</em></p>

<h4>Number of leaves</h4>

<p>An <em>n</em>-element nearly complete binary tree has ⌈n/2⌉ leaves.     <em>(Notice the
&quot;ceiling&quot; notation. Left as exercise.)</em></p>

<h4>Nodes of height <em>h</em> in a nearly complete binary tree (6.3-3)</h4>

<p>There are at most ⌈n/2h+1⌉ nodes of height <em>h</em> in a nearly complete binary
tree. (A proof by contradiction is possible.)</p>

<h3>The Heap Property</h3>

<p>Depending on whether it is a <em>max heap</em> or a <em>min heap</em>, to be a heap the
binary tree must also satisfy a heap property:</p>

<p><strong>Max Heap Property:</strong></p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">For all nodes _i_, excluding the root, key(parent(_i_)) ≥ key(_i_).  
</code></pre></div>
<p>By induction and transitivity of ≥, the max heap property guarantees that the
maximum element of a max-heap is at the root.</p>

<p><strong>Min Heap Property:</strong></p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">For all nodes _i_, excluding the root, key(parent(_i_)) ≤ key(_i_).  
</code></pre></div>
<p>By induction and transitivity of ≤, the min heap property guarantees that the
minimum element of a min heap is at the root.</p>

<h3>Array Representation</h3>

<p>Heaps are usually represented using arrays, following the mapping shown by the
indices in the tree:</p>

<p><img src="fig/Fig-6-1-max-heap-tree-array-indices.jpg" alt="">
<img src="fig/Fig-6-1-max-heap-array.jpg" alt="">  </p>

<p>The fact that we can see a heap both as a binary tree and as an array is an
example of a powerful idea in computer science: mapping between an
implementation representation that has efficient computational properties and
a conceptual representation that fits how we think about a problem.</p>

<p><img src="fig/code-parent-children.jpg" alt=""></p>

<p>If a heap is stored in array <code>A</code>, then movement in the tree is easy:</p>

<ul>
<li>Root of the tree is <code>A[1]</code></li>
<li>Parent of <code>A[_i_]</code> is <code>A[⌊_i_/2⌋]</code>     <em>(Notice we are taking the floor of _i</em>/2)_.</li>
<li>Left Child of <code>A[_i_]</code> is <code>A[_2i_]</code></li>
<li>Right Child of <code>A[_i_]</code> is <code>A[_2i+1_]</code></li>
<li>Index operations are fast in binary (left and right shifts and setting the low order bit).</li>
</ul>

<h4>Indices of leaves (6.1-7)</h4>

<p>By the number of leaves fact, when an <em>n</em>-element heap is stored in the array
representation, the leaves are the nodes indexed by ⌊n/2⌋ + 1, ⌊n/2⌋ + 2,
..., <em>n</em>. (Left as exercise.)</p>

<p>This fact will be used in algorithms that only need to process either the
leaves or the internal nodes of a heap.</p>

<hr>

<h2>Building and Maintaining Heaps</h2>

<h3>Maintaining the Heap Property</h3>

<p>MAX-HEAPIFY is used to maintain the max-heap property by addressing a possible
violation at node <code>A[_i_]</code>:</p>

<ul>
<li>MAX-HEAPIFY assumes that the left and right subtrees of <em>i</em> are max-heaps.</li>
<li>When called, <code>A[_i_]</code> may (or may not) be smaller than its children, violating the max-heap property if it is.</li>
<li>After MAX-HEAPIFY, the subtree rooted at <em>i</em> will be a heap. 
<img src="fig/code-max-heapify.jpg" alt=""></li>
</ul>

<p>It works by comparing <code>A[_i_]</code> with its left and right children (lines 3-7),
and if necessary swapping <code>A[_i_]</code> with the larger of the two children to
preserve the heap property (lines 8-9). <em>Tail recursion</em> after the swap
propagates this change until the subtree is a heap (line 10).</p>

<h4>Example</h4>

<p>Max-Heapify from the node at index 2 (containing 4):</p>

<p><img src="fig/Fig-6-2-max-heapify.jpg" alt=""></p>

<h4>Analysis</h4>

<p>It is easy to see that the body of each call before recursion is O(1), and the
recursion repeats this for at most O(lg <em>n</em>) nodes on the path from the root
to the leaves.</p>

<p>More formally, the worst case is when the bottom level is exactly half full,
and in this case, the <em>children&#39;s subtrees</em> can have at most 2<em>n</em>/3 nodes. So,
adding the cost to recurse on these subtrees plus Θ(1) cost for comparisons at
a given node, we get the recurrence relation:</p>

<blockquote>
<p><em>T</em>(<em>n</em>)   ≤   <em>T</em>(2<em>n</em>/3) + Θ(1).</p>
</blockquote>

<p>This fits case 2 of the Master Theorem (<em>a</em> = 1, <em>b</em> = 3/2 since 1/(3/2) =
2/3, and <em>f</em>(<em>n</em>) = 1 = O(<em>n</em>log3/21) = O(<em>n</em>0)), giving Θ(lg <em>n</em>).</p>

<h3>Building a Heap</h3>

<p>Suppose we load some keys into an array in arbitrary order from left to right,
creating an almost complete binary tree that may not satisfy the heap
property.</p>

<p>Each leaf of the corresponding tree is trivially a heap. If we call MAX-
HEAPIFY on the parents of the leaves, the assumption that the right and left
subtrees are heaps is met. Once MAX-HEAPIFY returns, the parents are roots of
heaps too, so we call it on <em>their</em> parents.</p>

<p>Using the previously established result that the leaves begin in the array at
index ⌊n/2⌋ + 1, so the last non-leaf node is at ⌊n/2⌋, the implementation is
trivial:</p>

<p><img src="fig/code-build-max-heap.jpg" alt=""></p>

<h4>Example</h4>

<p><img src="fig/Fig-6-3-build-max-heap-array.jpg" alt=""></p>

<p>Let&#39;s trace this on an array of size 10, for <em>i</em> = 5 downto 1:</p>

<p><img src="fig/Fig-6-3-build-max-heap-ab.jpg" alt=""></p>

<p>(a) The heap rooted at vertex or array index 5 is already a max heap: no
change is made.</p>

<p>(b) The heap rooted at index 4 is not a max heap: the value 2 is smaller than
its children. We restore the max heap property by swapping 2 with the larger
child key, 14 (see next figure for result). If we had swapped with 8, it would
not be a max heap: this is why we always swap with the larger child.</p>

<p><img src="fig/Fig-6-3-build-max-heap-cd.jpg" alt=""></p>

<p>(c) Decrementing <em>i</em> to 3, there is another violation of the max heap
property, and we swap value 3 at index 3 with value 10 at index 7 (the larger
child).</p>

<p>(d) The heap at index 2 violates the max heap property: we must propagate the
value 1 down by swapping with 16, and then with 7 in a recursive call to Max-
Heapify (see next figure).</p>

<p><img src="fig/Fig-6-3-build-max-heap-ef.jpg" alt=""></p>

<p>(e) Finally, checking the value at index 1 (value 4) against its children, we
find we need to swap it with value 16 at index 2, and then with value 14 at
index 4 and value 8 at index 9 in two recursive calls to Max-Heapify. (f)
shows the resulting max heap.</p>

<h4>Correctness</h4>

<p><img src="fig/code-build-max-heap.jpg" alt=""></p>

<p><em><strong>Loop Invariant:</strong></em></p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">At the start of every iteration of the `for` loop, each node _i_+1, _i_+2, ..., _n_ is a root of a max heap.
</code></pre></div>
<p><em><strong>Initialization:</strong></em></p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">By Exercise 6.1-7, each node ⌊n/2⌋ \+ 1, ⌊n/2⌋ \+ 2, ..., _n_ is a leaf, which is the root of a trivial max-heap. Since _i_ = ⌊n/2⌋ before the first iteration of the `for` loop, the invariant is initially true. 
</code></pre></div>
<p><em><strong>Maintenance:</strong></em></p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">Children of node _i_ are indexed higher than _i_, so by the loop invariant, they are both roots of max-heaps. Thus the assumption of MAX-HEAPIFY is met, enabling it to make node _i_ a max-heap root. Decrementing _i_ reestablishes the loop invariant at each iteration.
</code></pre></div>
<p><em><strong>Termination:</strong></em></p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">The loop terminates when _i_ = 0. By the loop invariant, each node including the root indexed by 1 is the root of a max-heap.
</code></pre></div>
<h4>Analysis</h4>

<p>Sometimes a good approach is to prove an easy bound and then tighten it.</p>

<p>It is easy to see that there are O(<em>n</em>) (about <em>n</em>/2) calls to MAX-HEAPIFY,
and we already know that MAX-HEAPIFY on a tree of height O(lg <em>n</em>) is O(lg
<em>n</em>). Therefore an upper bound is O(<em>n</em> lg <em>n</em>).</p>

<p>However, only the root node and those near it are at height O(lg <em>n</em>). Many
nodes are close to the leaves and we don&#39;t even process half of them. So let&#39;s
try for a tighter bound ...</p>

<p>There are no more than ⌈n/2h+1⌉ nodes of height <em>h</em> (Exercise 6.3-3), and the
heap is ⌊lg<em>n</em>⌋ high (Exercise 6.1-2). MAX-HEAPIFY called on a node of height
<em>h</em> is O(<em>h</em>), so we need to sum this cost times the number of nodes at each
<em>h</em> for all relevant <em>h</em>:</p>

<p><img src="fig/analysis-build-max-heap-1.jpg" alt=""></p>

<p>We can simplify this as follows:</p>

<ol>
<li>Wrap big-O around the whole thing, leaving h behind.</li>
<li>Remove the ceiling (which does not affect big-O analysis).</li>
<li>Rewrite the resulting <em>nh</em>/2<em>h</em>+1 as (<em>n</em>/2)(h/2<em>h</em>).</li>
<li>Move <em>n</em>/2 out of the summation, as it does not involve <em>h</em>.</li>
<li>Eliminate the constant 1/2, as we are inside the magical world of big-O!</li>
</ol>

<p>Tricky, huh? Now maybe you can see why the text authors write that as:</p>

<p><img src="fig/analysis-build-max-heap-2.jpg" alt=""></p>

<p>The above summation runs up to ⌊lg<em>n</em>⌋, but we would like to use a convenient
formula A-8, shown below, which runs up to ∞:</p>

<p><img src="fig/formula-A-8.jpg" alt=""></p>

<p>Since big-O implies an inequality (upper bound), we can go ahead and run the
summation to ∞ instead of ⌊lg<em>n</em>⌋, because all of the additional terms are
positive (and also very small), so the inequality will be maintained. Then, if
we let <em>x</em> = 1/2 (since <em>h</em>/2<em>h</em> = <em>h</em>(1<em>h</em>/2<em>h</em>) can be written as h(1/2)h),
we get:</p>

<p><img src="fig/analysis-build-max-heap-3.jpg" alt=""></p>

<p>Thus our big-O expression simplifies to O(<em>n</em>*2) = O(<em>n</em>), which is a tighter
bound than O(<em>n</em> lg <em>n</em>). The same analysis appliles to the min-heap version.</p>

<p>(You might wonder why we can build a heap in O(<em>n</em>) time when sorting takes
O(<em>n</em> lg <em>n</em>), as will be proven in <a href="http://www2.hawaii.edu/%7Esuthers/courses/ics311s14/Notes/Topic-10.html">Topic
10</a>.
This is because a heap is only a partial order, so less work needs to be done
to guarantee the heap property.)</p>

<hr>

<h2>Application to Sorting</h2>

<p>Suppose <code>A[1.._n_]</code> contains keys to be sorted. If we call BUILD-MAX-HEAP on
this array, the maximum element will be at <code>A[1]</code>. We can swap it with the
item at <code>A[_n_]</code>, then repeat on <code>A[1.._n_-1]</code> (reducing the size of the heap
by 1 each iteration) until this reaches size 1.</p>

<p><img src="fig/code-heapsort.jpg" alt=""></p>

<h4>Analysis:</h4>

<p>BUILD-MAX-HEAP is O(<em>n</em>) (by analysis above). The <code>for</code> loop executes <em>n</em>-1
times, with O(1) exchange each iteration and a call to O(lg <em>n</em>) MAX-HEAPIFY.
Thus heapsort is O(<em>n</em> lg <em>n</em>).</p>

<h4>Example:</h4>

<p>Suppose we have an array A with five integers. First, BUILD-MAX-HEAP is called
on it, resulting in the array A = [7, 4, 3, 1, 2] shown as the tree in (a)
below.</p>

<p><img src="fig/Fig-6-4-heapsort-alt-ab.jpg" alt=""></p>

<p>Then the loop of HEAPSORT successively takes out the maximum from the first
index by swapping it with the last element in the heap, and calls MAX-HEAPIFY.
So, 7 is swapped with 2, and then the heap (now one smaller) is reconstructed,
resulting in the heap shown in (b): A = [4, 2, 3, 1, 7], with the first four
elements being the heap.</p>

<p><img src="fig/Fig-6-4-heapsort-alt-cd.jpg" alt=""></p>

<p>The maximum element 4 (from b) was swapped with the minimum element 1
(removing 4 from the heap) and the heap restored, resulting in (c) A = [3, 2,
1, 4, 7] with the first three elements being the heap. Then in (d), the max
element 3 was swapped with 1 and the heap restored by percolating 1 down: A =
[2, 1, 3, 4, 7] with the heap being the first two elements.</p>

<p><img src="fig/Fig-6-4-heapsort-alt-e.jpg" alt=""></p>

<p>(e) Finally, the maximum element 2 is removed by swapping with the only
remaining element 1, resulting in the sorted array shown.</p>

<p>Here is a <a href="http://www.youtube.com/watch?v=WYII2Oau_VY">playing card
demonstration</a> of heap sort, in
case it helps. This demonstration is using a <em>min-heap</em> to sort the cards with
the card of <em>maximum</em> value ending up at the top of the stack of cards.</p>

<hr>

<h2>Application to Priority Queues</h2>

<p>An important application of heaps is implementing <strong>priority queues</strong>. There
are <em>min</em> and <em>max</em> versions.</p>

<p>A <strong>max-priority queue</strong> is an ADT with the following operations:</p>

<p>INSERT(S,<em>x</em>)</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">S &lt;- S ∪ {_x_}
</code></pre></div>
<p>MAXIMUM(S)</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">Returns the element of S with the largest key.
</code></pre></div>
<p>EXTRACT-MAX(S)</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">Removes and returns the element of S with the largest key.
</code></pre></div>
<p>INCREASE-KEY(S,<em>x</em>,<em>k</em>)</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">Increases the value of _x_&#39;s key to the new value _k_ ≥ current key(_x_).
</code></pre></div>
<p>A <strong>min-priority queue</strong> has corresponding operations MINIMUM, EXTRACT-MIN,
and DECREASE-KEY.</p>

<p>Max-priority queues can be used in job scheduling: the highest priority job is
always run next, but job priority can be increased as a job ages in the queue,
or for other reasons.</p>

<p>Min-priority queues will be very important in graph algorithms we cover later
in the semester: efficient implementations of EXTRACT-MIN and DECREASE-KEY
will be especially important.</p>

<p>Min-priority queues also used in event-driven simulations, where an event may
generate future events, and we need to simulate the events in chronological
order.</p>

<h4>Accessing Maximums</h4>

<p>In the array representation, MAXIMUM is trival to implement in O(1) by
returning the first element of the array. However, if we EXTRACT-MAX we need
to restore the heap property afterwards.</p>

<p>HEAP-EXTRACT-MAX takes the root out, replaces it with the last element in the
heap <em>(stop and think: why this element?)</em>, and then uses MAX-HEAPIFY to
propagate that element (which probably has a small key) down to its proper
place:</p>

<p><img src="fig/code-heap-extract-max.jpg" alt=""></p>

<p>HEAP-EXTRACT-MAX is O(lg <em>n</em>) since there is only constant work added to the
O(lg <em>n</em>) MAX-HEAPIFY.</p>

<h4>Increasing keys</h4>

<p>An increase to the key may require propagating the element <em>up</em> the tree (the
opposite direction as compared to MAX-HEAPIFY):</p>

<p><img src="fig/code-heap-increase-key.jpg" alt=""></p>

<p>This is clearly O(lg <em>n</em>) due to following a simple path up the tree. Let&#39;s
work this example, where the element at <em>i</em> has its key increased from 4 to
15, and then it is propagated up:</p>

<p><img src="fig/Fig-6-5-heap-increase-key.jpg" alt=""></p>

<p>This propagation follows the &quot;Peter Principle&quot;: the claim that persons in a
hierarchical organization are promoted through the ranks of management until
they reach their level of incompetency!!!</p>

<h4>Inserting New Elements</h4>

<p>When inserting, we are going to have to make the heap bigger, so let&#39;s add the
element at the end and propagate it up to where it belongs.</p>

<p>HEAP-INCREASE-KEY already has the code for this propagation, so if we set the
key to the smallest possible value and then try to increase it with HEAP-
INCREASE-KEY, it will end up in the right place:</p>

<p><img src="fig/code-max-heap-insert.jpg" alt=""></p>

<p>Again, this is O(lg <em>n</em>).</p>

<hr>

<h2>Next</h2>

<p>In <a href="http://www2.hawaii.edu/%7Esuthers/courses/ics311s14/Notes/Topic-10.html">Topic
10</a> we
wrap up our examination of sort algorithms with Quicksort, a practical sort
that performs well in practice and also illustrates the value of probabilistic
analysis and random algorithms.</p>

<p>We will return to other kinds of trees, in particular special kinds of binary
search trees that are kept balanced to guarantee O(lg <em>n</em>) performance, in
<a href="http://www2.hawaii.edu/%7Esuthers/courses/ics311s14/Notes/Topic-11.html">Topic
11</a>.</p>

<hr>

<p>Dan Suthers Last modified: Sat Feb 15 16:37:46 HST 2014<br>
Images are from the instructor&#39;s material for Cormen et al. Introduction to
Algorithms, Third Edition.  </p>

</div>



<div class="dark-blue-background">
<footer>
  <div class="container page-footer">
    
      <p>Daniel Suthers | Information and Computer Sciences | University of Hawaii <br>
suthers@hawaii.edu</p>

    
    <p style="margin: 0">Powered by the <a style="color: white" href="http://morea-framework.github.io/">Morea Framework</a><br>
       Last update on: <span>2014-04-15 15:24:21 -1000</span></p>
  </div>
</footer>
</div>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <title> Chapter 7 Notes | ICS 311 Spring 2014 </title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="utf-8">
  <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootswatch/3.1.0/cerulean/bootstrap.min.css">

  <!--  Load site-specific customizations after bootstrap. -->
  <link rel="stylesheet" href="/ics311s14/css/style.css">
  <link rel="stylesheet" href="/ics311s14/css/syntax.css">
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Open+Sans:normal,italic,bold">
  <link rel="shortcut icon" href="/ics311s14/favicon.ico" type="image/x-icon" />

  <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!--[if lt IE 9]>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.2/html5shiv.js"></script>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/respond.js/1.2.0/respond.js"></script>
  <![endif]-->

  <!-- Load Bootstrap JavaScript components -->
  <script src="http://code.jquery.com/jquery.min.js"></script>
  <script src="http://netdna.bootstrapcdn.com/bootstrap/3.1.0/js/bootstrap.min.js"></script>
</head>
<body>
<!-- Responsive navbar -->
<div class="navbar navbar-default navbar-inverse navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
        <!--  Display three horizontal lines when navbar collapsed. -->
        <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="#"> ICS 311 Spring 2014 </a>
    </div>
    <div class="collapse navbar-collapse">
      <ul class="nav navbar-nav">
        <li><a href="/ics311s14/index.html">Home</a></li>
        <li><a href="/ics311s14/modules/">Modules</a></li>
        <li><a href="/ics311s14/outcomes/">Outcomes</a></li>
        <li><a href="/ics311s14/readings/">Readings</a></li>
        <li><a href="/ics311s14/experiences/">Experiences</a></li>
        <li><a href="/ics311s14/assessments/">Assessments</a></li>
        <li><a href="/ics311s14/schedule/">Schedule</a></li>
        
      </ul>
    </div>
  </div>
</div>


<div class="container">
  <h1>Outline</h1>

<ol>
<li>Divide &amp; Conquer and Recurrences</li>
<li>Substitution Method</li>
<li>Recursion Trees</li>
<li>Master Theorem &amp; Method</li>
</ol>

<h2>Divide &amp; Conquer Strategy</h2>

<p><strong>Divide</strong>
    the problem into subproblems that are smaller instances of the same problem. 
<strong>Conquer</strong>
    the subproblems by solving them recursively. If the subproblems are small enough, solve them trivially or by &quot;brute force.&quot;
<strong>Combine</strong>
    the subproblem solutions to give a solution to the original problem.</p>

<h2>Recurrences</h2>

<p>The recursive nature of D&amp;C leads to <em>recurrences</em>, or functions defined in
terms of:</p>

<ul>
<li>one or more base cases, and </li>
<li>itself, with smaller arguments.</li>
</ul>

<p>Reviewing from <a href="http://www2.hawaii.edu/%7Esuthers/courses/ics311s14/No%0Ates/Topic-02.html#mergesort">Topic #2</a>, a common (but not the only) form of recurrence
is as follows. Let <em>T</em>(<em>n</em>) be the running time on a problem of size <em>n</em>.</p>

<ul>
<li>If <em>n</em> is below some constant (often, <em>n</em>=1), we can solve the problem directly with brute force or trivially in Θ(1) time.</li>
<li>Otherwise we divide the problem into <em>a</em> subproblems, each 1/<em>b</em> size of the original. </li>
<li>We pay cost <em>D</em>(<em>n</em>) to divide the problems and <em>C</em>(<em>n</em>) to combine the solutions. </li>
<li>We also pay cost <em>aT</em>(<em>n</em>/<em>b</em>) solving subproblems. </li>
</ul>

<p>Then the total time to solve a problem of size <em>n</em> can be expressed as:</p>

<p><img src="fig/recurrence-generic.jpg" alt=""></p>

<p>Some technical points should be made:</p>

<ul>
<li>Subproblems are not constrained to being a constant fraction of the original problem size, for example, you can have T(<em>n</em>) = T(<em>n-1</em>) + Θ(1).   <em>(What&#39;s an example algorithm that this describes?)</em></li>
<li>There can be other forms, such as multiple ways of dividing the problem. The book gives an example page 91 that divides the problem into 1/3 and 2/3 parts, requiring terms for T(<em>n/3</em>) and T(<em>2n/3</em>)</li>
<li>Floors and ceilings can easily be removed and don&#39;t affect the solution to the recurrence.</li>
<li>Boundary conditions (the smaller order terms that result from base cases) are usually Θ(1) and are omitted from asymptotic analyses, though they do matter for exact solutions.</li>
<li>Recurrences can be inequalities. We use Big-O or Ω as appropriate. </li>
</ul>

<p>Today we cover three approaches to solving such relations: substitution,
recursion tree, and the master method. But first, we look at two examples, one
of which we have already seen ...</p>

<h3>Merge Sort</h3>

<p>Sort an array A[<em>p</em> .. <em>r</em>] of comparable elements recursivly by divide and
conquer:</p>

<p><strong>Divide:</strong>
    Given A[<em>p</em> .. <em>r</em>], split the given array into two subarrays A[<em>p</em> .. <em>q</em>] and A[<em>q</em>+1 .. <em>r</em>] where <em>q</em> is the halfway point of A[<em>p</em> .. <em>r</em>].
<strong>Conquer:</strong>
    Recursively sort the two subarrays. If they are singletons, we have the base case. 
<strong>Combine:</strong>
    Merge the two sorted subarrays with a (linear) procedure Merge ... 
<img src="fig/code-merge-sort.jpg" alt=""></p>

<p>We have seen in <a href="http://www2.hawaii.edu/%7Esuthers/courses/ics311s14/No%0Ates/Topic-02.html#mergesort">Topic 2</a> that this has the following recurrence (please
review Topic 2 if you don&#39;t see why):</p>

<p><img src="fig/recurrence-merge-subarray.jpg" alt=""></p>

<h3>Recursive Solution to Maximum Subarray</h3>

<p>Suppose you have an array of numbers and need to find the subarray with the
maximum sum of elements in the subarray. (The problem is trival unless there
are negative numbers involved.)</p>

<p><img src="fig/Fig-4-3-Maximum-Subarray.jpg" alt=""></p>

<p>The book provides a not very convincing application: there are applications to
graphics (2D version: finding the brightest spot in an image).</p>

<p>The following algorithm is not the fastest known (a linear solution exists),
but it illustrates divide and conquer. The solution strategy, given an array
A[<em>low</em> .. <em>high</em>], is:</p>

<p><strong>Divide</strong>
     the subarray into two subarrays of equal size as possible by finding the midpoint <em>mid</em> of the subarrays. 
<strong>Conquer</strong>
    by finding a maximum subarray of A[<em>low</em> .. <em>mid</em>] and A[<em>mid</em>+1 .. <em>high</em>].
<strong>Combine</strong>
    by also finding a maximum subarray that crosses the midpoint, and using the best solution of the three (the subarray crossing the midpoint and the best of the solutions in the Conquer step).</p>

<p>The strategy works because any subarray must lie in one of these three
positions:</p>

<p><img src="fig/Fig-4-4-a-Subarrays.jpg" alt=""></p>

<h4>Pseudocode</h4>

<p>Recursion will handle the lower and upper halves. The algorithm relies on a
helper to find the crossing subarray. Any maximum subarray crossing the
midpoint must include arrays ending at A[<em>mid</em>] and starting at A[<em>mid</em>+1]:</p>

<p><img src="fig/Fig-4-4-b-Crossing.jpg" alt=""></p>

<p>Therefore the pseudocode finds the maximum array on each side and adds them
up:</p>

<p><img src="fig/find-max-crossing-subarray.jpg" alt=""></p>

<p>It should be clear that the above is Θ(n). The recursive solution follows.</p>

<p><img src="fig/find-maximum-subarray.jpg" alt=""></p>

<p><em>Check your understanding: Where is the work done? What adds up the values in
the left and right subarrays?</em></p>

<h4>Analysis</h4>

<p>The analysis relies on the simplifying assumption that the problem size is a
power of 2 (the same assumption for merge sort). Let T(<em>n</em>) denote the running
time of FIND-MAXIMUM-SUBARRAY on a subarray of <em>n</em> elements.</p>

<p><strong>Base case:</strong>
    Occurs when <em>high</em> equals <em>low</em>, so that <em>n=1</em>: it just returns in Θ(1) time. </p>

<p><strong>Recursive Case</strong> (when <em>n</em>&gt;1):</p>

<ul>
<li>Dividing takes Θ(1) time. </li>
<li>Conquering solves two subproblems, each on an array of n/2 elements: 2T(<em>n</em>/2). </li>
<li>Combining calls FIND-MAX-CROSSING-SUBARRAY, which takes Θ(<em>n</em>), and some constant tests: Θ(<em>n</em>) + Θ(1). 
T(<em>n</em>)   =   Θ(1) + 2T(<em>n</em>/2) + Θ(<em>n</em>) + Θ(1)   =   2T(<em>n</em>/2) + Θ(<em>n</em>).</li>
</ul>

<p>The resulting recurrence is the same as for merge sort:</p>

<p><img src="fig/recurrence-merge-subarray.jpg" alt=""></p>

<p>So how do we solve these? We have three methods: Substitution, Recursion
Trees, and the Master Method.</p>

<hr>

<h2>Substitution Method</h2>

<p>Don&#39;t you love it when a &quot;solution method&quot; starts with ...</p>

<ol>
<li>Guess the solution!</li>
<li>Use induction to find any unspecified constants and show that the solution works.</li>
</ol>

<p>Recursion trees (next section) are one way to guess solutions. Experience
helps too. For example, if a problem is divided in half we may expect to see
lg <em>n</em> behavior.</p>

<p>As an example, let&#39;s solve the recurrence for merge sort and maximum subarray.
We&#39;ll start with an exact rather than asymptotic version:</p>

<p><img src="fig/recurrence-merge-subarray-exact.jpg" alt=""></p>

<ol>
<li><p><strong>Guess:</strong>   T(<em>n</em>) = <em>n</em> lg <em>n</em> + <em>n</em>.  <em>(Why this guess?)</em></p></li>
<li><p><strong>Induction:</strong></p></li>
</ol>

<p><strong><em>Basis:</em></strong>
    <em>n</em> = 1   ⇒   <em>n</em> lg <em>n</em> + <em>n</em>   =   1 lg 1 + 1   =   1   =   T(<em>n</em>). </p>

<p><strong><em>Inductive Step:</em></strong>
    Inductive hypothesis is that T(<em>k</em>) = <em>k</em> lg <em>k</em> + <em>k</em> for all <em>k &lt; n</em>. We&#39;ll use <em>k = n/2</em>, and show that this implies that T(<em>n</em>) = <em>n</em> lg <em>n</em> + <em>n</em>. First we start with the definition of T(<em>n</em>); then we substitute ...<br>
<img src="fig/proof-merge-subarray-exact.jpg" alt=""></p>

<p>Induction would require that we show our solution holds for the boundary
conditions. This is discussed in the textbook.</p>

<p>Normally we use asymptotic notation rather than exact forms:</p>

<ul>
<li>writing T(<em>n</em>) = 2T(<em>n/2</em>) + O(<em>n</em>),</li>
<li>assuming T(<em>n</em>) = O(1) for sufficiently small <em>n</em>,</li>
<li>not worrying about boundary or base cases, and</li>
<li>writing solutions in asymptotic notation, e.g., T(<em>n</em>) = O(<em>n</em> lg <em>n</em>).</li>
</ul>

<p>If we want Θ, sometimes we can prove big-O and Ω separately &quot;squeezing&quot; the Θ
result.</p>

<p>But be careful when using asymptotic notation. For example, suppose you have
the case where <em>a</em>=4 and <em>b</em>=4 and want to prove T(<em>n</em>) = O(<em>n</em>) by guessing
that T(<em>n</em>) ≤ <em>cn</em> and writing:</p>

<p><img src="fig/false-proof.jpg" alt=""></p>

<p>One must prove the <em>exact form</em> of the inductive hypothesis, T(<em>n</em>) ≤ <em>cn</em>.</p>

<p>See the text for other strategies and pitfalls.</p>

<p>Problems 4.3-1 and 4.3-2 are good practice problems.</p>

<hr>

<h2>Recursion Trees</h2>

<p>Although recursion trees can be considered a proof format, they are normally
used to generate guesses that are verified by substitution.</p>

<ul>
<li>Each node represents the cost of a single subproblem in the set of recursive invocations</li>
<li>Sum the costs with each level of the tree to obtain per-level costs</li>
<li>Sum the costs across levels for the total cost.</li>
</ul>

<h3>A Familiar Example</h3>

<p>We have already seen recursion trees when analyzing the recurrence relations
for Merge Sort:</p>

<p><img src="fig/recurrence-mergesort-c.jpg" alt=""><br>
<img src="fig/recurrence-tree-mergesort-3.jpg" alt=""></p>

<p>The subproblems are of size <em>n</em>/20, <em>n</em>/21, <em>n</em>/22, .... The tree ends when
<em>n</em>/2<em>p</em> = <em>n</em>/<em>n</em> = 1, the trivial subproblem of size 1.</p>

<p>Thus the height of the tree is the power <em>p</em> to which we have to raise 2
before it becomes <em>n</em>, i.e., <em>p</em> = lg <em>n</em>. Since we start at 20 there are lg
<em>n</em> + 1 levels. Multiplying by the work <em>cn</em> at each level, we get <em>cn</em> lg
<em>n</em> + <em>cn</em> for the total time.</p>

<h3>A More Complex Example</h3>

<p>A more complex example is developed in the textbook for</p>

<blockquote>
<p>T(<em>n</em>) = 3T(<em>n</em>/4) + Θ(<em>n</em>2)</p>
</blockquote>

<p>which is rewritten (making the implied constant explicit) as</p>

<blockquote>
<p>T(<em>n</em>) = 3T(<em>n</em>/4)+ <em>cn</em>2</p>
</blockquote>

<p><img src="fig/Fig-4-5-Recursion-Tree-a.jpg" alt=""> node, T(<em>n</em>) = 3T(<em>n</em>/4)
+<em>cn</em>2.</p>

<p>We can develop the recursion tree in steps, as follows. First, we begin the
tree with its root <img src="fig/Fig-4-5-Recursion-Tree-b.jpg" alt=""></p>

<p>Now let&#39;s branch the tree for the three recursive terms 3T(<em>n</em>/4). There are
three children nodes with T(<em>n</em>/4) as their cost, and we leave the cost <em>cn</em>2
behind at the root node.</p>

<p>We repeat this for the subtrees rooted at each of the nodes for T(<em>n/4</em>):
Since each of these costs 3T((<em>n</em>/4)/4) +<em>c</em>(<em>n</em>/4)2, we make three branches,
each costing T((<em>n</em>/4)/4) = T(<em>n</em>/16), and leave the <em>c</em>(<em>n</em>/4)2 terms behind
at their roots.</p>

<p><img src="fig/Fig-4-5-Recursion-Tree-c.jpg" alt=""></p>

<p>Continuing this way until we reach the leaf nodes where the recursion ends at
trivial subproblems T(1), the tree looks like this:</p>

<p><img src="fig/Fig-4-5-Recursion-Tree-d.jpg" alt=""></p>

<p>Subproblem size for a node at depth <em>i</em> is <em>n</em>/4<em>i</em>, so the subproblem size
reaches <em>n</em> = 1 when (assuming <em>n</em> a power of 4) <em>n</em>/4<em>i</em> = 1, or when <em>i</em> =
log4<em>n</em>.<br>
Including <em>i</em> = 0, there are log4<em>n</em> + 1 levels. Each level has 3<em>i</em> nodes.<br>
Substituting <em>i</em> = log4<em>n</em> into 3<em>i</em>, there are 3log4<em>n</em> nodes in the bottom
level.<br>
Using alogbc = clogba, there are <em>n</em>log43 in the bottom level (<em>not</em> <em>n</em>, as
in the previous problem).</p>

<p>Adding up the levels, we get:<br>
<img src="fig/solution-recursion-tree-1.jpg" alt=""></p>

<p>It is easier to solve this summation if we change the equation to an
inequality and let the summation go to infinity (the terms are decreasing
geometrically), allowing us to apply equation A.6 (∑<em>k</em>=0,∞<em>xk</em> = 1/1-<em>x</em>):<br>
<img src="fig/gsolution-recursion-tree-2.jpg" alt=""></p>

<p>Additional observation: since the root contributes <em>cn2</em>, the root dominates
the cost of the tree, and the recurrence must also be Ω(<em>n</em>2), so we have
Θ(<em>n</em>2).</p>

<p>Please see the text for an example involving unequal subtrees. For practice,
exercises 4.4-6 and 4.4-9 have solutions posted on the book&#39;s web site.</p>

<hr>

<h2>Master Theorem &amp; Method</h2>

<p>If we have a divide and conquer recurrence of the form</p>

<blockquote>
<p>T(<em>n</em>) = <em>a</em>T(<em>n/b</em>) + <em>f(n)</em>  </p>
</blockquote>

<p>where <em>a ≥ 1</em>, <em>b &gt; 1</em>, and <em>f(n) &gt; 0</em> is asymptotically positive,</p>

<p>then we can apply the <strong>master method</strong>, which is based on the <strong>master
theorem</strong>. We compare <em>f(n)</em> to <em>nlogba</em> under asymptotic (in)equality:</p>

<p><strong>Case 1: <em>f(n)</em> = O(<em>nlogba - ε</em>)</strong> for some constant <em>ε</em> &gt; 0.<br>
    (That is, <em>f(n)</em> is polynomially smaller than <em>nlogba</em>.)<br>
    <strong><em>Solution:</em></strong> T(<em>n</em>) = <strong>Θ(<em>nlogba</em>).</strong><br>
    Intuitively: the cost is dominated by the leaves.</p>

<p><strong>Case 2: <em>f(n)</em> = Θ(<em>nlogba</em>)</strong>, or more generally (exercise 4.6-2): <em>f(n)</em> = Θ(<em>nlogba</em>lg<em>k</em><em>n</em>), where <em>k</em> ≥ 0.<br>
    (That is, <em>f(n)</em> is within a polylog factor of <em>nlogba</em>, but not smaller.)<br>
    <em><strong>Solution:</strong></em> T(<em>n</em>) = <strong>Θ(<em>nlogba</em>lg<em>n</em>),</strong> or T(<em>n</em>) = Θ(<em>nlogba</em>lg<em>k+1</em><em>n</em>) in the more general case.<br>
    Intuitively: the cost is <em>nlogba</em>lg<em>k</em> at each level and there are Θ(lg<em>n</em>) levels.</p>

<p><strong>Case 3: <em>f(n)</em>= Ω(<em>nlogba + ε</em>)</strong> for some constant <em>ε</em> &gt; 0, and <em>f(n)</em> satisfies the regularity condition <em>af(n/b) ≤ cf(n)</em> for some constant <em>c&lt;1</em> and all sufficiently large <em>n</em>.<br>
    (That is, <em>f(n)</em> is polynomially greater than <em>nlogba</em>.)<br>
    <em><strong>Solution:</strong></em> T(<em>n</em>) = <strong>Θ(<em>f(n)</em>)</strong>,<br>
    Intuitively: the cost is dominated by the root.</p>

<p>Important: there are functions that fall between the cases!</p>

<h3>Examples</h3>

<p><strong>T(<em>n</em>) = 5T(<em>n</em>/2) + Θ(<em>n</em>2)</strong></p>

<ul>
<li><em>a</em> = 5, <em>b</em> = 2, <em>f</em>(<em>n</em>) = <em>n</em>2</li>
<li>Compare   <em>n</em>2   to   <em>n</em>log<em>b</em><em>a</em> = <em>n</em>log25. </li>
<li>log25 - ε = 2 for some constant ε &gt; 0. </li>
<li>Case 1: T(<em>n</em>) = Θ(<em>n</em>lg 5). </li>
</ul>

<p><strong>T(<em>n</em>) = 27T(<em>n</em>/3) + Θ(<em>n</em>3 lg <em>n</em>)</strong></p>

<ul>
<li><em>a</em> = 27, <em>b</em> = 3, <em>f</em>(<em>n</em>) = <em>n</em>3 lg <em>n</em></li>
<li>Compare   <em>n</em>3 lg <em>n</em>   to   <em>n</em>log327 = <em>n</em>3</li>
<li>Case 2 with <em>k</em> = 1: T(<em>n</em>) = Θ(<em>n</em>3 lg2 <em>n</em>). </li>
</ul>

<p><strong>T(<em>n</em>) = 5T(<em>n</em>/2) + Θ(<em>n</em>3)</strong></p>

<ul>
<li><em>a</em> = 5, <em>b</em> = 2, <em>f</em>(<em>n</em>) = <em>n</em>3</li>
<li>Compare   <em>n</em>3   to   <em>n</em>log25</li>
<li>log25 + ε = 3 for some constant ε &gt; 0. </li>
<li><p>Check regularity condition (not necessary since <em>f</em>(<em>n</em>) is polynomial:<br>
<em>a</em><em>f</em>(<em>n</em>/<em>b</em>) = 5(<em>n</em>/2)3 = 5<em>n</em>3/8 ≤ <em>cn</em>3 for <em>c</em> = 5/8 &lt; 1.</p></li>
<li><p>Case 3: T(<em>n</em>) = Θ(<em>n</em>3). </p></li>
</ul>

<p><strong>T(<em>n</em>) = 27T(<em>n</em>/3) + Θ(<em>n</em>3 / lg <em>n</em>)</strong></p>

<ul>
<li><em>a</em> = 27, <em>b</em> = 3, <em>f</em>(<em>n</em>) = <em>n</em>3 / lg <em>n</em></li>
<li>Compare   <em>n</em>3/lg <em>n</em>   to   <em>n</em>log327 = <em>n</em>3</li>
<li>Cases 1 and 3 won&#39;t work as no ε can adjust the exponent of 3 to account for the 1/lg<em>n</em> = lg−1<em>n</em> factor. Only hope is Case 2. </li>
<li>But <em>n</em>3/lg <em>n</em> = <em>n</em>3 lg−1<em>n</em> ≠ Θ(<em>n</em>3 lg<em>k</em> <em>n</em>) for any <em>k</em> ≥ 0. </li>
<li>Cannot use master method. </li>
<li>Could try substitution, which requires a guess. Drawing the full recursion tree would be tedious, but perhaps visualizing its general form would help with the guess. </li>
</ul>

<hr>

<h2>Next</h2>

<p>Chapter 12, Binary Search Trees (entire chapter), to which we can apply divide
&amp; conquer and use recurrence relations.</p>

<hr>

<p>Dan Suthers Last modified: Sat Feb 8 02:42:12 HST 2014<br>
Images are from the instructor&#39;s material for Cormen et al. Introduction to
Algorithms, Third Edition.  </p>

</div>



<div class="dark-blue-background">
<footer>
  <div class="container page-footer">
    
      <p>Daniel Suthers | Information and Computer Sciences | University of Hawaii <br>
suthers@hawaii.edu</p>

    
    <p style="margin: 0">Powered by the <a style="color: white" href="http://morea-framework.github.io/">Morea Framework</a><br>
       Last update on: <span>2014-04-17 13:14:01 -1000</span></p>
  </div>
</footer>
</div>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <title> Chapter 8 Notes | ICS 311 Spring 2014 </title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="utf-8">

  <!--  Load bootswatch-based Morea theme file. -->
  <link rel="stylesheet" href="/ics311s14/css/themes/cerulean/bootstrap.min.css">
  <link rel="stylesheet" href="/ics311s14/css/style.css">
  <link rel="stylesheet" href="/ics311s14/css/syntax.css">
  <link rel="shortcut icon" href="/ics311s14/favicon.ico" type="image/x-icon" />

  <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!--[if lt IE 9]>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.2/html5shiv.js"></script>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/respond.js/1.2.0/respond.js"></script>
  <![endif]-->

  <!-- Load Bootstrap JavaScript components -->
  <script src="http://code.jquery.com/jquery.min.js"></script>
  <script src="http://netdna.bootstrapcdn.com/bootstrap/3.1.0/js/bootstrap.min.js"></script>
</head>
<body>
<!-- Responsive navbar -->
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
        <!--  Display three horizontal lines when navbar collapsed. -->
        <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="#"> ICS 311 Spring 2014 </a>
    </div>
    <div class="collapse navbar-collapse">
      <ul class="nav navbar-nav">
        <li><a href="/ics311s14/index.html">Home</a></li>
        <li><a href="/ics311s14/modules/">Modules</a></li>
        <li><a href="/ics311s14/outcomes/">Outcomes</a></li>
        <li><a href="/ics311s14/readings/">Readings</a></li>
        <li><a href="/ics311s14/experiences/">Experiences</a></li>
        <li><a href="/ics311s14/assessments/">Assessments</a></li>
        <li><a href="/ics311s14/schedule/">Schedule</a></li>
      </ul>
    </div>
  </div>
</div>


<div class="container">
  <h2 id="outline">Outline</h2>

<ol>
  <li>Trees, Binary Trees, Binary Search Trees </li>
  <li>Querying BSTs</li>
  <li>Modifying BSTs (Insertion and Deletion)</li>
  <li>Performance of BSTs </li>
</ol>

<h2 id="trees-binary-trees-binary-search-trees">Trees, Binary Trees, Binary Search Trees</h2>

<p>First, a preliminary look at trees. (This should be review. Some of this
material is taken from Thomas Standish Data Structure Techniques (1980) and
Goodrich &amp; Tamassia (1998) as well as the Cormen appendix, but is widely
published.)</p>

<h3 id="fundamental-theorem-of-free-trees">Fundamental Theorem of Free Trees</h3>

<p>If <em>G</em>=(<em>V</em>,<em>E</em>) is a finite graph with <em>v &gt; 1</em> vertices, the following
properties are equivalent definitions of a generalized or <strong>free tree</strong>:</p>

<ol>
  <li><em>G</em> is connected and has no simple cycles. </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td><em>G</em> has no simple cycles and has <em>v-1</em> edges (</td>
          <td><em>E</em></td>
          <td>=</td>
          <td><em>V</em></td>
          <td>- 1)</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li><em>G</em> is connected and has <em>v-1</em> edges.</li>
  <li><em>G</em> is acyclic, and if an edge is added that joins two nonadjacent vertices, exactly one cycle is formed.</li>
  <li><em>G</em> is connected, but if an edge is deleted, <em>G</em> becomes disconnected. </li>
  <li>Every pair of vertices is connected by exactly one path. </li>
</ol>

<p>Although this is a definition, the theorem is that these definitions are
equivalent. A classic exercise in basic graph theory is to prove each of these
statements using the one before it, and #1 from #6.</p>

<h4 id="comments">Comments</h4>

<p>When we use the term “tree” without qualification, we will assume that we mean
a free tree unless the context makes it clear otherwise (e.g., when we are
discussing binary trees).</p>

<p>In some contexts, <em>G</em>=({},{}) and <em>G</em>=({<em>v</em>},{}) are also treated as trees.
These are obvious base cases for recursive algorithms.</p>

<p>A <strong>forest</strong> is a (possibly disconnected) graph, each of whose connected
components is a tree.</p>

<p>An <strong>oriented tree</strong> is a directed graph having a designated vertex <em>r</em>,
called the <strong>root</strong>, and having exacly one oriented path between the root and
any vertex <em>v</em> distinct from the root, in which <em>r</em> is the origin of the path
and <em>v</em> the terminus.</p>

<p>In some fields (such as social network analysis), the word “node” is used
interchangeably with “vertex”. I use “vertex” in these notes but may slip into
“node” in my recorded lectures or in class.</p>

<p><img src="fig/diagram-tree-heights-tall.jpg" alt="" /></p>

<h3 id="binary-trees">Binary Trees</h3>

<p>A <strong>binary tree</strong> is a finite set of vertices that is either empty or consists
of a vertex called the root, together with two binary subtrees that are
disjoint from each other and from the root and are called the <strong>left</strong> and
<strong>right subtrees</strong>.</p>

<p>A **full binary tree ** is a binary tree in which each vertex either is a leaf
or has exactly two nonempty descendants. In a full binary tree of height <em>h</em>:</p>

<ol>
  <li>number of leaves = (number internal vertices) + 1.</li>
  <li>number leaves is at least <em>h</em>+1 <em>(first example figure)</em> and at most 2_h_ <em>(second example figure)</em>.</li>
</ol>

<p><img src="fig/diagram-tree-heights-wide.jpg" alt="" /></p>

<ol>
  <li>number internal vertices is at least <em>h</em> <em>(first example)</em> and at most 2_h<em>-1 _(second example)</em>.</li>
  <li>Total number of vertices (summing the last two results) is at least 2_h<em>+1 _(first example)</em> and at most 2_h+1<em>-1 _(second example)</em>.</li>
  <li>Height <em>h</em> is at least lg(<em>n</em>+1)-1 <em>(second example)</em> and at most (<em>n</em>-1)/2 <em>(first example)</em></li>
</ol>

<p>A **complete binary tree ** is full binary tree in which all leaves have the
same depth and all internal vertices have degree 2 <em>(e.g., second example
above)</em>.</p>

<p>(<em>Note:</em> some earlier texts allow the last level of a “complete” tree to be
incomplete! They are defined as binary trees with leaves on at most two
adjacent levels <em>l-1</em> and <em>l</em> and in which the leaves at the bottommost level
<em>l</em> lie in the leftmost positions of <em>l</em>.)</p>

<h3 id="binary-search-trees-bsts">Binary Search Trees (BSTs)</h3>

<p>A <strong>binary search tree</strong> (BST) is a binary tree that satisfies the <strong>binary
search tree property:</strong></p>

<ul>
  <li>if <em>y</em> is in the left subtree of <em>x</em> then <em>y.key ≤ x.key</em>. </li>
  <li>if <em>y</em> is in the right subtree of <em>x</em> then <em>y.key ≥ x.key</em>. </li>
</ul>

<p>BSTs provide a useful implementation of the Dynamic Set ADT, as they support
most of the operations efficiently (as will be seen).</p>

<p>Two examples on the same data:<br />
<img src="fig/Fig-12-1a-balanced.jpg" alt="" /> <img src="fig/Fig-12-1b-
unbalanced.jpg" alt="" /></p>

<p><em>Could we just just say “if y is the <strong>left child</strong> of x then y.key ≤ x.key,
etc., and rely on transitivity? What would go wrong?</em></p>

<p>Implementations of BSTs include a <em>root</em> instance variable. Implementations of
BST vertices usually include fields for the <em>key</em>, <em>left</em> and <em>right</em>
children, and the <em>parent</em>.</p>

<hr />

<h2 id="querying-binary-search-trees">Querying Binary Search Trees</h2>

<p>Note that all of the algorithms described here are given a tree vertex as a
starting point. Thus, they can be applied to any subtree of the tree as well
as the full tree.</p>

<h3 id="traversing-trees">Traversing Trees</h3>

<p>Traversals of the tree “visit” (e.g., print or otherwise operate on) each
vertex of the tree exactly once, in some systematic order. This order can be
<strong>Inorder</strong>, <strong>Preorder</strong>, or <strong>Postorder</strong>, according to when a vertex is
visited relative to its children. Here is the code for inorder:</p>

<p><img src="fig/pseudocode-inorder-tree-walk.jpg" alt="" /></p>

<p><em>Quick exercise: Do INORDER-TREE-WALK on this tree … in what order are the
keys printed?</em></p>

<p><img src="fig/example-BST-simple.jpg" alt="" /></p>

<p><em>Quick exercise: How would you define Preorder traversal? Postorder
traversal?</em></p>

<p>Traversals can be done on any tree, not just binary search trees. For example,
traversal of an expression tree will produce preorder, inorder or postorder
versions of the expressions.</p>

<h4 id="time-to-traverse-a-bst">Time to Traverse a BST</h4>

<p><strong>Time:</strong> Traversals (INORDER-TREE-WALK and its preorder and postorder variations) take <em>T</em>(<em>n</em>) = Θ(<em>n</em>) time for a tree with <em>n</em> vertices, because we visit and print each vertex once, with constant cost associated with moving between vertices and printing them. More formally, we can prove as follows:</p>

<p><em>T</em>(<em>n</em>) = Ω(<em>n</em>) since these traversals must visit all <em>n</em> vertices of the
tree.</p>

<p><em>T</em>(<em>n</em>) = O(<em>n</em>) can be shown by substitution. First the base case of the
recurrence relation captures the work done for the test <em>x</em> ≠ NIL:</p>

<blockquote>
  <p><em>T</em>(0) = <em>c</em> for some constant c &gt; 0</p>
</blockquote>

<p>To obtain the recurrence relation for <em>n</em> &gt; 0, suppose the traversal is called
on a vertex <em>x</em> with <em>k</em> vertices in the left subtree and <em>n</em>−<em>k</em>−1 vertices
in the right subtree, and that it takes constant time <em>d</em> &gt; 0 to execute the
body of the traversal exclusive of recursive calls. Then the time is bounded
by</p>

<blockquote>
  <p><em>T</em>(<em>n</em>) ≤ <em>T</em>(<em>k</em>) + <em>T</em>(<em>n</em>−<em>k</em>−1) + <em>d</em>.</p>
</blockquote>

<p>We now need to “guess” the inductive hypothesis to prove. The “guess” that
CLRS use is <em>T</em>(<em>n</em>) ≤ (<em>c</em> + <em>d</em>)<em>n</em> + <em>c</em>, which is clearly O(<em>n</em>). It’s
less clear how they got this guess. As discussed in Chapter 4, section 4
(especially subsection “Subtleties” page 85-86), one must prove the exact form
of the inductive hypothesis, and sometimes you can get a better guess by
observing how your original attempt at the proof fails. Perhaps this is what
they did. We’ll skip the failure part and go directly to proving their
hypothesis by substitution (showing two steps skipped over in the book):</p>

<blockquote>
  <p><strong><em>Inductive hypothesis:</em></strong> Suppose that <em>T</em>(<em>m</em>) ≤ (<em>c</em> + <em>d</em>)<em>m</em> + <em>c</em>
for all <em>m</em> &lt; <em>n</em>  </p>
</blockquote>

<p><strong><em>Base Case:</em></strong> (<em>c</em> + <em>d</em>)0 + <em>c</em> = <em>c</em> = <em>T</em>(0) as defined above.  </p>

<p><strong><em>Inductive Proof:</em></strong><br />
   <em>T</em>(<em>n</em>) ≤ <em>T</em>(<em>k</em>) + <em>T</em>(<em>n</em>−<em>k</em>−1) + <em>d</em>
<em>by definition</em><br />
           = ((<em>c</em> + <em>d</em>)<em>k</em> + <em>c</em>) + ((<em>c</em> + <em>d</em>)(<em>n</em>−<em>k</em>−1) + <em>c</em>) + <em>d</em>    <em>substiting inductive hypothesis for values &lt; n</em> <br />
            = ((<em>c</em> + <em>d</em>)(<em>k</em> + <em>n</em> − <em>k</em> − 1) + <em>c</em> + <em>c</em> + <em>d</em>             <em>collecting factors _ <br />
            = ((_c</em> + <em>d</em>)(<em>n</em> − 1) + <em>c</em> + <em>c</em> + <em>d</em>                         <em>simplifying _ <br />
            = ((_c</em> + <em>d</em>)<em>n</em> + <em>c</em> − (<em>c</em> + <em>d</em>) + <em>c</em> + <em>d</em>                   <em>multiplying out _n</em>−1 and rearranging _ <br />
            = ((<em>c</em> + <em>d</em>)<em>n</em> + <em>c</em>.                                            <em>the last terms cancel.</em></p>

<h3 id="searching-for-an-element-in-a-bst">Searching for an Element in a BST</h3>

<p>Here are two implementations of the dynamic set operation <code>search</code>:</p>

<p><img src="fig/pseudocode-recursive-tree-search.jpg" alt="" /> <img src="fig
/pseudocode-iterative-tree-search.jpg" alt="" /></p>

<p>_Quick exercise: Do TREE-SEARCH for D and C on this tree … _</p>

<p><img src="fig/example-BST-simple.jpg" alt="" /></p>

<p>For now, we will characterize the run time of the remaining algorithms in
terms of <em>h</em>, the height of the tree. Then we will consider what <em>h</em> can be as
a function of <em>n</em>, the number of vertices in the tree.</p>

<p><strong>Time:</strong> Both of the algorithms visit vertices on a downwards path from the root to the vertex sought. In the worst case, the leaf with the longest path from the root is reached, examining <em>h</em>+1 vertices (<em>h</em> is the height of the tree, so traversing the longest path must traverse <em>h</em> edges, and <em>h</em> edges connect <em>h</em>+1 vertices). Comparisons and movements to the chosen child vertex are O(1), so the algorithm is O(<em>h</em>). (<em>Why don’t we say Θ?</em>) </p>

<h3 id="finding-the-minimum-and-maximum-element">Finding the Minimum and Maximum Element</h3>

<p>The BST property guarantees that:</p>

<ul>
  <li>The minimum key of a BST is located at the leftmost vertex.</li>
  <li>The maximum key of a BST is located at the rightmost vertex.</li>
</ul>

<p><em>(Why?)</em> This leads to simple implementations:</p>

<p><img src="fig/pseudocode-tree-min-max.jpg" alt="" /> <img src="fig/example-
BST-simple.jpg" alt="" /></p>

<p><strong>Time:</strong> Both procedures visit vertices on a path from the root to a leaf. Visits are O(1), so again this algorithm is O(<em>h</em>).</p>

<h3 id="finding-the-successor-or-predecessor-of-an-element">Finding the Successor or Predecessor of an Element</h3>

<p>Assuming that all keys are distinct, the successor of a vertex <em>x</em> is the
vertex <em>y</em> such that <em>y.key</em> is the smallest <em>key</em> &gt; <em>x.key</em>. If <em>x</em> has the
largest key in the BST, we define the successor to be NIL.</p>

<p>We can find <em>x</em>’s successor based entirely on the tree structure (no key
comparison is needed). There are two cases:</p>

<ol>
  <li><strong>If vertex <em>x</em> has a non-empty right subtree, then <em>x</em>’s successor is the minimum in its right subtree.</strong> <em>(Why?)</em></li>
  <li><strong>If vertex <em>x</em> has an empty right subtree, then <em>y</em> is the lowest ancestor of <em>x</em> whose left child is also an ancestor of <em>x</em>.</strong>   <em>To see this, consider these facts: _
    * If _y</em> is the successor of <em>x</em> then <em>x</em> is the predecessor of <em>y</em>, so <em>x</em> is the maximum in <em>y</em>’s left subtree <em>(flip the reasoning of your answer to the last question)</em>.
    * Moving from <em>x</em> to the left up the tree (up through right children) reaches vertices with smaller keys, which must also be in this left subtree. 
<img src="fig/pseudocode-tree-successor.jpg" alt="" /></li>
</ol>

<p><em>Exercise: Write the pseudocode for TREE-PREDECESSOR</em></p>

<p>Let’s trace the min, max, successor (15, 13, 6, 4), and predecessor (6)
operations:</p>

<p><img src="fig/Fig-12-2-example-BST.jpg" alt="" /></p>

<p><strong>Time:</strong> The algorithms visit notes on a path down or up the tree, with O(1) operations at each visit and a maximum of <em>h+1</em> visitations. Thus these algorithms are O(<em>h</em>). </p>

<p><em>Exercise: Show that if a vertex in a BST has two children, then its succesor
has no left child and its predecessor has no right child.</em></p>

<hr />

<h2 id="modifying-binary-search-trees">Modifying Binary Search Trees</h2>

<p>The key point is that the BST property must be sustained. This is more
straightforward with insertion (as we can add a vertex at a leaf position)
than with deletion (where an internal vertex may be deleted).</p>

<h3 id="insertion">Insertion</h3>

<p>The algorithm assumes that the vertex <em>z</em> to be inserted has been initialized
with <em>z.key</em> = <em>v</em> and <em>z.left</em> = <em>z.right</em> = NIL.</p>

<p>The strategy is to conduct a search (as in tree search) with pointer <em>x</em>, but
to sustain a <strong>trailing pointer</strong> <em>y</em> to keep track of the parent of <em>x</em>. When
<em>x</em> drops off the bottom of the tree (becomes NIL), it will be appropriate to
insert <em>z</em> as a child of <em>y</em>.</p>

<p>Comment on variable naming: I would have preferred that they call <em>x</em>
something like <code>leading</code> and <em>y</em> <code>trailing</code>.</p>

<p><img src="fig/pseudocode-tree-insert.jpg" alt="" /></p>

<p>Try <code>TREE-INSERT(T,C)</code>:</p>

<p><img src="fig/example-BST-simple.jpg" alt="" /></p>

<p><strong>Time:</strong> The same as TREE-SEARCH, as there are just a few additional lines of O(1) pointer manipulation at the end.</p>

<p><em>Discuss: How would you use TREE-INSERT and INORDER-TREE-WALK to sort a set of
numbers?</em><br />
<em>Think about at home: How would you prove its time complexity?</em></p>

<h3 id="deletion">Deletion</h3>

<p>Deletion is more complex, as the vertex <em>z</em> to be deleted may or may not have
children. We can think of this in terms of three cases:</p>

<ol>
  <li>If <em>z</em> has no children, we can just remove it (by setting <em>z</em>’s parent’s pointer to NIL). </li>
  <li>If <em>z</em> has just one child <em>c</em>, then make <em>c</em> take <em>z</em>’s position in the tree, updating <em>z</em>’s parent to point to <em>c</em> and “dragging” <em>c</em>’s subtree along.</li>
  <li>If <em>z</em> has two children, find <em>z</em>’s successor <em>y</em> and replace <em>z</em> by <em>y</em> in the tree (noting that <em>y</em> has no left child): 
    * If <em>y</em> is <em>z</em>’s right child, then replace <em>z</em> by <em>y</em> (including updating <em>z</em>’s parent to point to <em>y</em>, and <em>y</em> to point to <em>z</em>’s left child) and we are done. 
    * Otherwise <em>y</em> is further down in <em>z</em>’s right subtree (and again has no left child): 
    <ol>
      <li>Replace <em>y</em> with its own right child. </li>
      <li>The rest of <em>z</em>’s right subtree becomes <em>y</em>’s new right subtree.</li>
      <li><em>z</em>’s left subtree becomes <em>y</em>’s new left subtree.</li>
      <li>Make <em>z</em>’s parent point to <em>y</em>.</li>
    </ol>
  </li>
</ol>

<p>The code organizes the cases differently to simplify testing and make use of a
common procedure for moving subtrees around. This procedure replaces the
subtree rooted at <em>u</em> with the subtree rooted at <em>v</em>.</p>

<ul>
  <li>It makes <em>u</em>’s parent become <em>v</em>’s parent (lines 6-7), unless <em>u</em> is the root, in which case it makes <em>v</em> the root (lines 1-2).</li>
  <li><em>v</em> replaces <em>u</em> as <em>u</em>’s parent’s left or right child (lines 3-5).</li>
  <li>It does not update <em>v.left</em> or <em>v.right</em>, leaving that up to the caller. 
<img src="fig/pseudocode-transplant.jpg" alt="" /></li>
</ul>

<p><em>(If we have time, draw a few examples.)</em></p>

<p>Here are the four actual cases used in the main algorithm TREE-DELETE(T,<em>z</em>):</p>

<p><img src="fig/Fig-12-4-a-no-left-child.jpg" alt="" /></p>

<h4 id="no-left-child-and-possibly-no-children">No left child (and possibly no children):</h4>

<p>If <em>z</em> has no left child, replace <em>z</em> by its right child (which may or may not
be NIL). This handles case 1 and half of case 2 in the conceptual breakdown
above. (Lines 1-2 of final algorithm.)</p>

<p><img src="fig/Fig-12-4-b-no-right-child.jpg" alt="" /></p>

<h4 id="no-right-child-and-has-left-child">No right child (and has left child):</h4>

<p>If <em>z</em> has just one child, and that is its left child, then replace <em>z</em> by its
left child. This handles the rest of case 2 in the conceptual breakdown above.
(Lines 3-4.)</p>

<p>Now we just have to deal with the case where both children are present. Find
<em>z</em>’s successor (line 5), which must lie in <em>z</em>’s right subtree and have no
left child (<em>why?</em>). Handling depends on whether or not the successor is
immediately referenced by <em>z</em>:</p>

<p><img src="fig/Fig-12-4-c-successor-is-child.jpg" alt="" /></p>

<h4 id="successor-is-child">Successor is child:</h4>

<p>If successor <em>y</em> is <em>z</em>’s right child (line 6), replace <em>z</em> by <em>y</em>, “pulling
up” <em>y</em>’s right subtree. The left subtree of <em>y</em> is empty so we can make <em>z</em>’s
former left subtree <em>l</em> be <em>y</em>’s new left subtree. (Lines 10-12.)</p>

<h4 id="successor-is-not-child">Successor is not child:</h4>

<p>Otherwise, <em>y</em> is within <em>z</em>’s right subtree rooted at <em>r _but is not the root
of this subtree (_y≠r</em>).</p>

<ol>
  <li>Replace <em>y</em> by its own right child <em>x</em>. (Line 7.)</li>
  <li>Set <em>y</em> to be <em>r</em>’s parent. (Line 8-9.)</li>
  <li>Then let <em>y</em> take <em>z</em>’s place with respect to <em>z</em>’s parent __ and left child <em>l</em>. (Lines 10-12.)
<img src="fig/Fig-12-4-d-successor-not-child.jpg" alt="" /></li>
</ol>

<p>Now we are ready for the full algorithm:</p>

<p><img src="fig/pseudocode-tree-delete.jpg" alt="" /></p>

<p>The last three lines excecute whenever <em>z</em> has two children (the last two
cases above).</p>

<p>Let’s try <code>TREE-DELETE(T,_x_)</code> on <em>x=</em> I, G, K, and B:</p>

<p><img src="fig/example-BST-to-delete.jpg" alt="" /></p>

<p><strong>Time:</strong> Everything is O(1) except for a call to TREE-MINIMUM, which is O(<em>h</em>), so TREE-DELETE is O(<em>h</em>) on a tree of height <em>h</em>. </p>

<p>The above algorithm fixes a problem with some published algorithms, including
the first two editions of the book. Those versions copy data from one vertex
to another to avoid a tree manipulation. If other program components maintain
pointers to tree vertices (or their positions in Goodrich &amp; Tamassia’s
approach), this could invalidate their pointers. The present version
guarantees that a call to TREE-DELETE(T, <em>z</em>) deletes exactly and only vertex
<em>z</em>.</p>

<p>An animation is available at
<a href="http://www.csc.liv.ac.uk/~ullrich/COMP102/applets/bstree/">http://www.csc.liv.ac.uk/~ullrich/COMP102/applets/bstree/</a> (The code shown
probably has the flaw discussed above.)</p>

<hr />

<h2 id="performance-of-binary-search-trees">Performance of Binary Search Trees</h2>

<p>We have been saying that the asympotic runtime of the various BST operations
(except traversal) are all O(lg <em>h</em>), where <em>h</em> is the height of the tree. But
<em>h</em> is usually hidden from the user of the ADT implementation and we are more
concerned with the runtime as a function of <em>n</em>, our input size. So, what is
<em>h</em> as a function of <em>n</em>?</p>

<p>We know that in the worst case, <em>h</em> = O(<em>n</em>) (when the tree degenerates to a
linear chain). Is this the expected case? Can we do anything to guarantee
better performance? These two questions are addressed below.</p>

<h3 id="expected-height-of-randomly-built-binary-search-trees">Expected height of randomly built binary search trees</h3>

<p>The textbook has a proof in section 12.4 that <strong>the expected height of a
randomly build binary search tree on <em>n</em> distinct keys is O(lg <em>n</em>).</strong></p>

<p>We are not covering the proof (and you are not expected to know it), but I
recommend reading it, as the proof elegantly combines many of the ideas we
have been developing, including indicator random variables and recurrences.
(They take a huge step at the end: can you figure out how the log of the last
polynomial expression simplifies to O(lg <em>n</em>)?)</p>

<p>An alternative proof provided by Knuth (Art of Computer Programming Vol. III,
1973, p 247), and also summarized by Standish, is based on average path
lengths in the tree. It shows that about 1.386 lg <em>n</em> comparisons are needed:
<strong>the average tree is about 38.6% worse than the best possible tree in number
of comparisons required for average search</strong>.</p>

<p>Surprisingly, <em>analysts have not yet been able to get clear results when
random deletions are also included</em>.</p>

<h3 id="balanced-trees">Balanced Trees</h3>

<p>Given the full set of keys in advance, it is possible to build an optimally
balanced BST for those keys (guaranteed to be lg <em>n</em> height). See section 15.5
of the Cormen et al. text.</p>

<p>If we don’t know the keys in advance, many clever methods exist to keep trees
balanced, or balanced within a constant factor of optimal, by performing
manipulations to re-balance after insertions (AVL trees, Red-Black Trees), or
after all operations (in the case of splay trees). We cover Red-Black Trees in
two weeks (<a href="http://www2.hawaii.edu/~suthers/courses/ics311s14/Notes/Topic-11.html">Topic
11</a>),
after a diversion to heaps (which have tree-like structure) and sorting.</p>

<hr />

<h2 id="next">Next</h2>

<p>In <a href="http://www2.hawaii.edu/~suthers/courses/ics311s14/Notes/Topic-09.html">Topic
09</a> we
look at how a special kind of tree, a Heap, can be embedded in an array and
used to implement a sorting algorithm and priority queues.</p>

<p>After a brief diversion to look at other sorting algorithms, we will return to
other kinds of trees, in particular special kinds of binary search trees that
are kept balanced to guarantee O(lg <em>n</em>) performance, in <a href="http://www2.hawaii.edu/~suthers/courses/ics311s14/Notes/Topic-11.html">Topic
11</a>.</p>

<hr />

<p>Dan Suthers Last modified: Sun Feb 16 02:15:30 HST 2014<br />
Images are from the instructor’s material for Cormen et al. Introduction to
Algorithms, Third Edition.  </p>


</div>



<div class="footer-background">
<footer>
  <div class="container page-footer">
    
      <p>Daniel Suthers | Information and Computer Sciences | University of Hawaii <br />
suthers@hawaii.edu</p>

    
    <p style="margin: 0">Powered by the <a style="color: white" href="http://morea-framework.github.io/">Morea Framework</a> (Theme: cerulean)<br>
       Last update on: <span>2014-05-13 09:04:38 -1000</span></p>
  </div>
</footer>
</div>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <title> Experience single source shortest paths | ICS 311 Spring 2014 </title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="utf-8">
  <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootswatch/3.1.0/cerulean/bootstrap.min.css">

  <!--  Load site-specific customizations after bootstrap. -->
  <link rel="stylesheet" href="/ics311s14/css/style.css">
  <link rel="stylesheet" href="/ics311s14/css/syntax.css">
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Open+Sans:normal,italic,bold">
  <link rel="shortcut icon" href="/ics311s14/favicon.ico" type="image/x-icon" />

  <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!--[if lt IE 9]>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.2/html5shiv.js"></script>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/respond.js/1.2.0/respond.js"></script>
  <![endif]-->

  <!-- Load Bootstrap JavaScript components -->
  <script src="http://code.jquery.com/jquery.min.js"></script>
  <script src="http://netdna.bootstrapcdn.com/bootstrap/3.1.0/js/bootstrap.min.js"></script>
</head>
<body>
<!-- Responsive navbar -->
<div class="navbar navbar-default navbar-inverse navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
        <!--  Display three horizontal lines when navbar collapsed. -->
        <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="#"> ICS 311 Spring 2014 </a>
    </div>
    <div class="collapse navbar-collapse">
      <ul class="nav navbar-nav">
        <li><a href="/ics311s14/index.html">Home</a></li>
        <li><a href="/ics311s14/modules/">Modules</a></li>
        <li><a href="/ics311s14/outcomes/">Outcomes</a></li>
        <li><a href="/ics311s14/readings/">Readings</a></li>
        <li><a href="/ics311s14/experiences/">Experiences</a></li>
        <li><a href="/ics311s14/assessments/">Assessments</a></li>
        <li><a href="/ics311s14/schedule/">Schedule</a></li>
        
      </ul>
    </div>
  </div>
</div>


<div class="container">
  <h3>Bellman-Ford</h3>

<h4>1. Modifying Bellman-Ford to exit early when all paths are done.</h4>

<p>Suppose we have modified the Relax procedure to return TRUE if it changed an
edge weight and FALSE otherwise. This enables us to write a better
encapsulated version of Bellman-Ford, shown below.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">Bellman-Ford(G,w,S)
1  Initialize-Single-Source(G,s)
2  for i = 1 to |G.V| - 1
3      for each edge (u,v) in G.E
4          Relax(u,v,w) 
5  for each edge (u,v) in G.E
6      if Relax(u,v,w) 
7          return FALSE
8  return TRUE
</code></pre></div>
<p>But Bellman-Ford still does unnecessary work if all shortest paths are
significantly shorter than |G.V| - 1. Modify the code above to exit the
algorithm early with the correct value if there will be no further changes. Do
this by modifying Bellman-Ford alone: don&#39;t change the Relax procedure.</p>

<h3>Dijkstra&#39;s Algorithm</h3>

<h4>2. Dijkstra&#39;s algorithm and negative weight edges.</h4>

<p>Dijkstra&#39;s algorithm assumes (based on the triangle inequality) that once a
vertex v is moved to S, v.d = δ(s, v). It is not supposed to be able to handle
graphs with negative weight edges, such as the graph shown below, because they
violate the triangle inequality.</p>

<p><img src="fig/code-Dijkstra.jpg" alt=""> <img src="fig/Dijkstra-False-Counterexample.jpg" alt=""></p>

<p>But nothing in Dijkstra&#39;s algorithm says lines 7-8 can&#39;t update weights of
vertices that are already in S. If you simulate the algorithm, you will see
that when vertex y is dequeued, vertex z (which is already in S) should be
updated to its correct distance δ(s, z). Why won&#39;t this always happen? Can you
modify the graph to be one for which v.d ≠ δ(s, v) at the end for some v?</p>

<h3>DAG Shortest Paths</h3>

<h4>3. Parallel scheduling with critical paths in a DAG</h4>

<p>The parallel scheduling problem is to take a set of interdependent jobs with
known execution time and determine when to schedule each job so that the last
job finishes as soon as possible while respecting the interdependency
constraints.</p>

<p>We can model such problems using weighted DAGs as follows:</p>

<ol>
<li>Create a DAG with a start node <em>s</em>, a finish node <em>f</em>, and two vertices for each job <em>j</em>: a job start vertex <em>j</em>s and a job end vertex <em>j</em>f.</li>
<li>For each job, add an edge from its start vertex to its end vertex with weight equal to its duration. (This models the time required for the job.) </li>
<li>For each precedence constraint where job <em>i</em> must finish before job <em>j</em> starts, add a zero-weight edge from <em>i</em>f to <em>j</em>s. (This models precedence constraints where one job relies on another having been finished, but can start immediately after it finished: hence the 0.)</li>
<li>Also add zero-weight edges from the start node <em>s</em> to every job start node <em>j</em>s and from every job finish node <em>j</em>f to the finish node <em>f</em>. (The start vertex gives us a place to begin the shortest paths algorithm and the finish vertex gives us a place where we will assign the finishing time.) </li>
</ol>

<p><img src="fig/PS-11-Jobs.jpg" alt=""></p>

<p>But we need an algorithm to do the scheduling. Rather than write an algorithm
from scratch, we will see how we can do this with DAG-Shortest-Paths. Some
adjustment may be required to make the data structure fit the algorithm.</p>

<p>Some jobs are shown in the table to the right. The first job should start at
time 0. Your task is to schedule the jobs such that they are all completed in
the minimum amount of time while respecting the constraints. You will complete
this on your homework: here we will ensure we understand the approach.</p>

<p><strong>(a)</strong> Do we need to find the shortest paths or the longest paths, and why? </p>

<p><strong>(b)</strong> Do you need to change the weights in any way to solve it with DAG-Shortest-Paths, and if so how and why? </p>

<p><strong>(c)</strong> After running DAG-Shortest-Paths, how do you extract the solution, specifically the start time of each job and the time at which all jobs will be finished? </p>

</div>



<div class="dark-blue-background">
<footer>
  <div class="container page-footer">
    
      <p>Daniel Suthers | Information and Computer Sciences | University of Hawaii <br>
suthers@hawaii.edu</p>

    
    <p style="margin: 0">Powered by the <a style="color: white" href="http://morea-framework.github.io/">Morea Framework</a><br>
       Last update on: <span>2014-04-23 11:34:04 -1000</span></p>
  </div>
</footer>
</div>
</body>
</html>

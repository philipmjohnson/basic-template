<!DOCTYPE html>
<html>
<head>
  <title> Notes on balanced trees | ICS 311 Spring 2014 </title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="utf-8">

  <!--  Load bootswatch-based Morea theme file. -->
  <link rel="stylesheet" href="/ics311s14/css/themes/cerulean/bootstrap.min.css">
  <link rel="stylesheet" href="/ics311s14/css/style.css">
  <link rel="stylesheet" href="/ics311s14/css/syntax.css">
  <link rel="shortcut icon" href="/ics311s14/favicon.ico" type="image/x-icon" />

  <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!--[if lt IE 9]>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.2/html5shiv.js"></script>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/respond.js/1.2.0/respond.js"></script>
  <![endif]-->

  <!-- Load Bootstrap JavaScript components -->
  <script src="http://code.jquery.com/jquery.min.js"></script>
  <script src="http://netdna.bootstrapcdn.com/bootstrap/3.1.0/js/bootstrap.min.js"></script>
</head>
<body>
<!-- Responsive navbar -->
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
        <!--  Display three horizontal lines when navbar collapsed. -->
        <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="#"> ICS 311 Spring 2014 </a>
    </div>
    <div class="collapse navbar-collapse">
      <ul class="nav navbar-nav">
        <li><a href="/ics311s14/index.html">Home</a></li>
	<li class="dropdown">
          <a class="dropdown-toggle" data-toggle="dropdown" href="#">Course Info<b class="caret"></b></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="/morea/010.introduction/reading-course-info.html">Overview</a></li>
              <li><a href="/morea/010.introduction/reading-policies.html">Policies</a></li>
              <li><a href="/morea/010.introduction/reading-topic-overview.html">Topics</a></li>
            </ul>
          </li>
        <li><a href="/ics311s14/modules/">Modules</a></li>
        
          <li><a href="/ics311s14/outcomes/">Outcomes</a></li>
        
        
          <li><a href="/ics311s14/readings/">Readings</a></li>
        
        
          <li><a href="/ics311s14/experiences/">Experiences</a></li>
        
        
        <li><a href="/ics311s14/news/">News</a></li>
      </ul>
    </div>
  </div>
</div>


<div class="container">
  <h2 id="outline">Outline</h2>

<ul>
  <li>Balanced and Multi-Way Trees </li>
  <li>2-3-4 or (2,4) Trees </li>
  <li>Red-Black Trees 
    <ul>
      <li>as a binary representation of (2,4) trees</li>
      <li>as binary search trees</li>
    </ul>
  </li>
  <li>Insertion in Red-Black Trees</li>
  <li>Deletion in Red-Black Trees</li>
  <li>Comparison of Dictionary Implementations</li>
</ul>

<p><em>(Much of this material is derived from Goodrich &amp; Tamassia’s slides widely
available on the Web.)</em></p>

<hr />

<h2 id="multi-way-trees">Multi-Way Trees</h2>

<p>A <strong>multi-way search tree</strong> is an ordered tree such that</p>

<ul>
  <li>Each internal node has at least two children and stores <em>d</em>-1 key-element items (<em>ki</em>, <em>oi</em>), where <em>d</em> is the number of children</li>
  <li>For a node with children <em>v1</em> <em>v2</em> … <em>vd</em> storing keys <em>k1</em> <em>k2</em> … <em>kd-1</em>
    <ul>
      <li>keys in the subtree of <em>v1</em> are less than <em>k1</em></li>
      <li>keys in the subtree of <em>vi</em> are between <em>ki-1</em> and <em>ki</em> (<em>i</em> = 2, …, <em>d</em> - 1)</li>
      <li>keys in the subtree of <em>vd</em> are greater than <em>kd-1</em></li>
    </ul>
  </li>
  <li>The leaves store no items and serve as placeholders</li>
</ul>

<p><img src="fig/GT-multiway-search-tree.jpg" alt="" /></p>

<p><strong>Multi-way inorder traversal</strong> can be defined by extension of BST inorder traversal to visit the keys in increasing order:</p>

<blockquote>
  <p>Visit item (<em>ki</em>, <em>oi</em>) of node <em>v</em> between the recursive traversals of the
subtrees of <em>v</em> rooted at children <em>vi</em> and <em>vi+1</em>.</p>
</blockquote>

<p><img src="fig/GT-multiway-inorder-traversal.jpg" alt="" /></p>

<p><strong>Searching</strong> can similarly be extended to multi-way trees by searching within each node as well as down the tree:</p>

<ul>
  <li>At each internal node with children <em>v1</em> <em>v2</em> … <em>vd</em> and keys <em>k1</em> <em>k2</em> … <em>kd-1</em>: 
    <ul>
      <li><em>k</em> = <em>ki</em> (<em>i</em> = 1, … , <em>d</em> - 1): the search terminates with success</li>
      <li><em>k</em> &lt; <em>k1</em>: we continue the search in child <em>v1</em></li>
      <li><em>ki-1</em> &lt; <em>k</em> &lt; <em>ki</em> (<em>i</em> = 2, … , <em>d</em> - 1): we continue the search in child <em>vi</em></li>
      <li><em>k</em> &gt; <em>kd-1</em>: we continue the search in child <em>vd</em></li>
    </ul>
  </li>
  <li>Reaching an external node terminates the search unsuccessfully</li>
</ul>

<p>For example, searching for key 30:</p>

<p><img src="fig/GT-multiway-searching.jpg" alt="" /></p>

<hr />

<h2 id="or-2-3-4-trees">(2,4), 2-4 or 2-3-4 Trees</h2>

<p>These are multi-way trees restricted in two ways:</p>

<ul>
  <li><strong>Node Size Property</strong>: every internal node has at least two children (one key) and at most four children (three keys).</li>
  <li><strong>Depth Property</strong>: all of the external nodes have the same depth. (The tree is balanced.)</li>
</ul>

<p>The internal nodes are called 2-nodes, 3-nodes or 4-nodes, depending on the
number of children they have.</p>

<p><img src="fig/GT-2-4-trees.jpg" alt="" /></p>

<h3 id="height-of-24-trees-and-searching">Height of (2,4) Trees and Searching</h3>

<p><strong><em>Theorem:</em> A (2,4) tree storing n items has height Θ(log n).</strong></p>

<p>Proof:</p>

<p>Let <em>h</em> be the height of a (2,4) tree with <em>n</em> items. The tallest possible
tree (worst case) for a fixed <em>n</em> is when all internal nodes are 2-nodes
(i.e., the tree is equivalent to a binary tree), so we restrict consideration
to this case. Due to the depth property, the tree at depth <em>h</em>-1 is filled, so
it is a complete binary tree.</p>

<p><img src="fig/GT-2-4-tree-height.jpg" alt="" /></p>

<p>The figure illustrates the number of nodes in each level of a complete binary
tree. Since there are at least 2_i_ items at depth <em>i</em> = 0, … , <em>h</em>-1 and no
items at depth <em>h</em> (the leaves store no items):<br />
    <em>n</em> ≥ 1 + 2 + 4 + … + 2_h<em>-1<br />
(we use ≥ because there could be more items in internal 3-nodes or 4-nodes,
leading to “better cases” where _n</em> increases without a penalty in <em>h</em>).</p>

<p><img src="fig/formula-A-5.jpg" alt="" /></p>

<p>Applying formula A5 (shown) for geometric series with <em>n</em> = <em>h</em>-1 and <em>x</em> = 2,<br />
1 + 2 + 4 + … + 2_h<em>-1 = Σ_k</em>=0,<em>h</em>-12_k_ = (2(h-1) + 1 - 1)/(2 - 1) = 2_h_
- 1, so<br />
    <em>n</em> ≥ = 2_h_ - 1   or   n + 1 ≥ 2_h_</p>

<p>Taking the log of both sides:   lg (<em>n</em> + 1) ≥ <em>h</em>.<br />
Thus, <em>h</em> = Θ(lg <em>n</em>).</p>

<p>(See also similar facts concerning full binary trees in <a href="http://www2.hawaii.edu/~suthers/courses/ics311f12/Notes/Topic-08.html">Topic
8</a>.)</p>

<p>Since searching in a (2,4) tree with <em>n</em> items requires time proportional to a
path from root to leaves, searching is <strong>O(lg <em>n</em>)</strong> time.</p>

<h3 id="tree-insertion">(2,4) Tree Insertion</h3>

<p>We will examine insertion and deletion briefly to understand the conceptual
cases.</p>

<p>Insert a new item keyed by <em>k</em> into <em>(not below)</em> the parent of the leaf
reached by searching for <em>k</em>. (<em>In this respect, (2,4) trees differ from
binary search trees.</em>)</p>

<p>This preserves depth but may cause <strong>overflow</strong> (a node may become a 5-node).</p>

<p><em>Example:</em> Inserting 30, we find its position between 27 and 32. However
inserting here causes overflow:</p>

<p><img src="fig/GT-2-4-tree-insertion.jpg" alt="" /></p>

<p>Overflow is handled with a <strong>split operation</strong>, as illustrated below with a
simpler tree:</p>

<ul>
  <li>The 5-node containing keys <em>k1</em>, <em>k2</em>, <em>k3</em>, <em>k4</em> is split into a 3-node with keys <em>k1</em>, <em>k2</em> and a 2-node with key <em>k4</em>.</li>
  <li>Key <em>k3</em> is inserted into the parent node (as would be the case with the tree above).</li>
  <li>Overflow may propagate to the parent node.</li>
  <li>A new root may be created if the root overflows.</li>
</ul>

<p><img src="fig/GT-2-4-tree-overflow-split.jpg" alt="" /></p>

<p><em>(Note: Sedgewick splits 4-nodes on the way down while searching for the
insertion position, guaranteeing that there will be no overflow. Both Goodrich
&amp; Tamassia and Cormen et al. take the other approach, propagating splits
upwards only as needed. The asymptotic time complexity remains the same.)</em></p>

<h4 id="time-complexity-of-24-insertion">Time Complexity of (2,4) Insertion</h4>

<p>A tree with <em>n</em> items has Θ(lg <em>n</em>) height. The algorithm first searches for
the insertion location, which may require visiting <em>h</em> = Θ(lg <em>n</em>) nodes (Θ,
not O, because we must go to the leaves in all cases). The insertion takes
Θ(1) time. If there is overflow, splits (taking Θ(1) time each) may be
propagated upwards to as many as O(lg <em>n</em>) nodes. Since the Θ(lg <em>n</em>)
overrides the possibility of slower growing functions in O(lg <em>n</em>), insertion
is <strong>Θ(lg <em>n</em>)</strong>.</p>

<h3 id="tree-deletion">(2,4) Tree Deletion</h3>

<p>If the entry to be deleted is in a node that has internal nodes as children,
we replace the entry to be deleted with its inorder successor and delete the
latter entry. Example: to delete key 24, we replace it with 27 (inorder
successor):</p>

<p><img src="fig/GT-2-4-tree-deletion.jpg" alt="" /></p>

<p>This reduces deletion of an entry to the case where the item is at the node
with leaf children.</p>

<p>Deletion of an entry from a node <em>v</em> may cause <strong>underflow,</strong> where node <em>v</em>
becomes a 1-node with one child and no keys. Underflow at node <em>v</em> with parent
<em>u</em> is handled in two cases.</p>

<p><strong><em>Case 1</em></strong>: An adjacent sibling of <em>v</em> is a 2-node. Perform a <strong>fusion operation</strong>, merging <em>v</em> with the adjacent 2-node sibling <em>w</em> and moving an entry from <em>u</em> to the merged node <em>v’</em>.</p>

<p><img src="fig/GT-2-4-tree-underflow-fusion.jpg" alt="" /></p>

<p>After a fusion, the underflow may propagate to the parent u, for at most O(lg
<em>n</em>) adjustments up the tree.</p>

<p><strong><em>Case 2</em></strong>: An adjacent sibling <em>w</em> of <em>v</em> is a 3-node or a 4-node. Perform a <strong>transfer operation:</strong> move a child of <em>w</em> to <em>v</em>; an item from <em>u</em> to <em>v</em>; and an item from <em>w</em> to <em>u</em>. </p>

<p><img src="fig/GT-2-4-tree-underflow-transfer.jpg" alt="" /></p>

<p>A transfer eliminates underflow.</p>

<h4 id="time-complexity-of-24-deletion">Time Complexity of (2,4) Deletion</h4>

<p>The algorithm first searches for the item to delete, which requires visiting
<em>h</em> = Θ(lg <em>n</em>) nodes on the way down the tree, either to find a bottom level
key to delete, or to find the successor of a key in an internal node to
delete. Underflow is handled with up to O(lg <em>n</em>) fusions and transfers, each
taking Θ(1) time. Thus deletion is <strong>Θ(lg <em>n</em>)</strong>.</p>

<hr />

<h2 id="red-black-trees">Red-Black Trees</h2>

<h3 id="red-black-tree-properties">Red-Black Tree Properties</h3>

<p><img src="fig/Simple-Red-Black-Tree.jpg" alt="" /></p>

<p>A red-black tree (RBT) is a binary search tree with the following additional
properties:</p>

<ol>
  <li><strong>Color property</strong>: Every node is either red or black. <em>(We can indicate this either by coloring the node or by coloring its parent link.)</em></li>
  <li><strong>Root property</strong>: The root is black</li>
  <li><strong>External property</strong>: Every leaf is black.</li>
  <li><strong>Internal property</strong>: If a node is red, then both of its children are black. <em>(Hence, no two reds in a row are allowed on a simple path from the root to a leaf.)</em></li>
  <li><strong>Depth property</strong>: For each node, all the paths from the node to descendant leaves contain the same number of black nodes (the <strong>black height</strong> of the node).</li>
</ol>

<p>These properties seem rather arbitrary until we consider the correspondence
with (2,4) trees shortly, but first let’s see how the properties hold in an
example …</p>

<p><img src="fig/Fig-13-1-RBT-Representation-a.jpg" alt="" /></p>

<h3 id="red-black-tree-representation">Red-Black Tree Representation</h3>

<p>A single extra bit is required on each node to mark it as “red” or “black”.</p>

<p>To save space, we can represent the leaf nodes <em>and</em> the parent with a single
node, T.nil:</p>

<p><img src="fig/Fig-13-1-RBT-Representation-b.jpg" alt="" /></p>

<p>This also simplifies the code, as we can follow pointers without having to
check for null pointers.</p>

<p>We usually don’t draw T.nil:</p>

<p><img src="fig/Fig-13-1-RBT-Representation-c.jpg" alt="" /></p>

<h3 id="rbts-as-a-binary-representation-of-24-trees">RBTs as a Binary Representation of (2,4) Trees</h3>

<p>It would be rather complex to implement and manipulate 2-nodes, 3-nodes and
4-nodes. One motivation for red-black trees is that they provide a binary tree
representation of (2,4) trees, enabling us to manipulate only one kind of
node. The mapping is as follows (<strong>you should make sure you understand this
well before going on!</strong>):</p>

<p><img src="fig/GT-From-2-4-to-RBT.jpg" alt="" /></p>

<p><strong>Red nodes (and the links from their parents) capture the <em>internal structure of a (2,3) node</em>;</strong></p>

<p><strong>Black nodes (and the links from their parents) capture the <em>structure of the (2,3) tree</em> itself.</strong></p>

<h3 id="rbts-as-binary-search-trees">RBTs as Binary Search Trees</h3>

<p>At the same time as they represent (2,4) trees, <em><strong>RBTs are also Binary Search
Trees</strong></em>: they satisfy the Binary Search Tree property. For example, here is a
RBT: we can search for keys or enumerate elements in order as usual:</p>

<p><img src="fig/GT-RBTs.jpg" alt="" /></p>

<p>In order to maintain the Red-Black-Tree properties, it will be necessary to do
structural rotations. These rotations are designed to not disrupt the BST
property. For example, this rotation does not disturb the BST ordering of keys
9, 11, 12, 14, 17, 18, 19:</p>

<p><img src="fig/Fig-13-3-Rotation-BST.jpg" alt="" /></p>

<h4 id="height-of-red-black-trees-and-searching">Height of Red-Black Trees and Searching</h4>

<p>Theorem: A red-black tree storing n items has height Θ(lg <em>n</em>).<br />
Proof:</p>

<ul>
  <li>Let <em>h</em> be the height of a red-black tree with <em>n</em> items</li>
  <li>By property 4, there cannot be more red nodes (and links) on a simple path from the root to a leaf than there are black nodes (and links). </li>
  <li>Therefore the black height of the root of the tree is between <em>h</em> and <em>h</em>/2. </li>
  <li>The black height of the root of the red-black tree corresponds to the height <em>h’</em> of the (2,4) tree that the red-black tree represents (since red nodes/links in the RBT represent the internal structure of the nodes in the (2,4) tree). </li>
  <li>From the theorem concerning the height of (2,4) trees, <em>h’</em> is Θ(lg <em>n</em>). </li>
  <li>Since <em>h</em> is no more than twice <em>h’</em>, <em>h</em> is also Θ(lg <em>n</em>).</li>
</ul>

<p>(See Cormen et al. for a proof not relying on (2,4) trees.)</p>

<p>Therefore, searching in a red-black tree with <em>n</em> items takes <strong>O(lg <em>n</em>)</strong>
time (O rather than Θ as we may find the key in an internal node).</p>

<p>We now consider insertion and deletion. Please see the textbook for the many
details of implementation in pseudocode, etc.: here we will concentrate on
seeing how the RBT operations correspond to (2,4) tree operations.</p>

<h3 id="insertion-in-red-black-trees">Insertion in Red-Black Trees</h3>

<p>To insert an element with key <em>k</em>, perform the insertion for binary search
trees (except that conceptually we insert <em>k</em> in an internal node with null
children, not at a leaf node), and color the newly inserted node <em>z</em> red,
unless it is the root.</p>

<p>This preserves the color, root, external, and depth properties. <em>(You should
check this in the example below.)</em></p>

<p>If the parent <em>v</em> of <em>z</em> is black, this also preserves the internal property
and we are done.</p>

<p>Else (<em>v</em> is red), we have a <strong>double red</strong> (i.e., a violation of the internal
property), which requires a reorganization of the tree. For example, insert 4:</p>

<p><img src="fig/GT-RBT-insertion.jpg" alt="" /></p>

<p>A double red with child <em>z</em> and parent <em>v</em> is dealt with in two cases. Let <em>w</em>
be the sibling of <em>v</em> (and hence the uncle of <em>z</em>).</p>

<p><strong><em>Case 1:</em></strong> <em>w</em> is black. The double red is an <em><strong>incorrect representation</strong></em> of a 4-node. (We will fix this with restructuring). For example, the RBT on the left is an incorrect representation of the (2,4) tree on the right:</p>

<p><img src="fig/GT-RBT-double-red-case-1.jpg" alt="" /></p>

<p><strong><em>Case 2:</em></strong> w is red. The double red corresponds to an <em><strong>overflow</strong></em> in the (2,4) tree. (We will fix this with recoloring, which is the equivalent of a (2,4) split.) For example:</p>

<p><img src="fig/GT-RBT-double-red-case-2.jpg" alt="" /></p>

<h4 id="restructuring">Restructuring</h4>

<p><strong>Restructuring</strong> remedies a child-parent double red when the parent red node has a black sibling. It restores the correct representation (internal property) of a 4-node, leaving other RBT and BST properties intact: </p>

<p><img src="fig/GT-RBT-restructuring.jpg" alt="" /></p>

<p>There are four restructuring configurations depending on whether the double
red nodes are left or right children. They all lead to the same end
configuration of a black with two red children:</p>

<p><img src="fig/GT-RBT-restructuring-configurations.jpg" alt="" /></p>

<p>After a restructuring, the double red has been remedied without violating any
of the other properties <em>(you should verify this)</em>: there is no need to
propagate changes upwards.</p>

<p>Notice that the height of the subtree tree has been reduced by one. **<em>This is
the operation that keeps the trees balanced to within a constant factor of
lg(_n</em>) height<em>**, by ensuring that the height of the RBT is no more than
twice that of the (necessarily balanced) 2-4 tree it represents. _Do you see
why?</em></p>

<h4 id="recoloring">Recoloring</h4>

<p><strong>Recoloring</strong> remedies a child-parent double red when the parent red node has a red sibling. The parent <em>v</em> and its sibling <em>w</em> become black and the grandparent <em>u</em> becomes red, unless it is the root.</p>

<p>It is equivalent to performing a split on a 5-node in a (2,4) tree. (When
there is a double red and yet another red in the parent’s sibling, we are
trying to collect too many keys under the grandparent.) For example, the RBT
recoloring on the top corresponds to the (2,4) transformation on the bottom:</p>

<p><img src="fig/GT-RBT-recoloring.jpg" alt="" /></p>

<p>Notice that in this example the parent “4” is now red, meaning it belongs to
its parent node in the (2,4) tree. The double red violation may propagate to
this parent in the RBT, which corresponds to the overflow propagating up the
(2,4) tree, requiring further repair.</p>

<h4 id="time-complexity-of-rbt-insertion">Time Complexity of RBT Insertion</h4>

<p>We already established that insertion in (2,4) trees is Θ(lg <em>n</em>) due to their
height. Since RBTs are only at most twice as high, we might expect this result
to transfer, and it does, but it needs to be shown separately since the
manipulations of the RBT are different. So:</p>

<ul>
  <li>The algorithm first searches for the insertion location, which will require visiting <em>h</em> = Θ(lg <em>n</em>) nodes on the way down the tree (since we are searching for a leaf node and the tree is balanced).</li>
  <li>Adding the item takes O(1). </li>
  <li>Recolorings and restructurings are Θ(1) each, and we perform at most O(lg <em>n</em>) recolorings and <em>one</em> restructuring propagating structural changes back up the tree.</li>
</ul>

<p>Thus insertion is <strong>Θ(lg <em>n</em>).</strong></p>

<p>Note: A top-down version of this algorithm is also possible, restructuring on
the way down and requiring only one pass through the tree. See the Sedgewick
reading distributed.</p>

<h3 id="deletion-in-red-black-trees">Deletion in Red-Black Trees</h3>

<p>To remove item with key <em>k</em>, we first perform the BST deletion (modified for
our representational changes using T.nil).</p>

<p>Because deletion of a node higher in the tree involves replacing it with its
successor, which is then deleted, deletion always involves an internal and an
external node.</p>

<p>We can preserve the RBT properties at the new internal location of the
successor by giving the successor the color of the node deleted, so we need
only be concerned with possible violations of RBT properties at the bottom of
the tree, where the successor was moved from, or where a node without a
successor was deleted.</p>

<p>Let <em>v</em> be the internal node removed, <em>w</em> the external node removed, and <em>r</em>
the sibling of <em>w</em>:</p>

<pre><code>    x       
     \               x                    
      v       ==&gt;     \
     / \               r 
    r   w
</code></pre>

<p>If either <em>v</em> or <em>r</em> was red, we color <em>r</em> black and we are done (the number
of black nodes has not changed).</p>

<p>Else (<em>v</em> and <em>r</em> were both black), we have removed a black node, violating
the depth property. We fix this by coloring <em>r</em> <strong>double black,</strong> a fictional
color. (Intuitively, the black of both <em>v</em> and <em>r</em> have been absorbed into
<em>r</em>.) Now we have the correct “amount” of black on this path from root to
leaf, but the double black violates the color property.</p>

<p>Fixing this will require a reorganization of the tree. Example: deletion of 8
causes a double black:</p>

<p><img src="fig/GT-RBT-deletion-double-black.jpg" alt="" /></p>

<p>A double black corresonds to <em><strong>underflow</strong></em> in (2,4) trees (and here the
images I am borrowing from Goodrich &amp; Tamassia go to greyscale!):</p>

<p><img src="fig/GT-double-black-as-underflow.jpg" alt="" /></p>

<p>Goodrich &amp; Tamassia’s algorithm for remedying a double black node <em>w</em> with
sibling <em>y</em> considers <em>three cases</em>, discussed below. <em>(Note that these are
different from CLRS’s four cases!)</em></p>

<p><strong><em>Case 1:</em></strong> <em>y</em> is black and has a red child: Perform a RBT <strong>restructuring</strong>, equivalent to a (2,4) <strong>transfer</strong>, and we are done.</p>

<p>For example, if we have the RBT on the left corresponding to underflow in the
(2,4) tree on the right:</p>

<p><img src="fig/GT-RBT-DB-remedy-case-1-1.jpg" alt="" /></p>

<p>… we do the following restructuring:</p>

<p><img src="fig/GT-RBT-DB-remedy-case-1-2.jpg" alt="" /></p>

<p><strong><em>Case 2:</em></strong> <em>y</em> is black and its children are both black: Perform a RBT <strong>recoloring</strong>, equivalent to a (2,4) <strong>fusion</strong>, which may propagate up the double black violation.</p>

<p>If the double-black reaches the root we can just remove it, as it is now on
<em>all</em> of the paths from the root to the leaves, so does not affect property 5,
the depth property.</p>

<p>For example, if we have the RBT on the left corresponding to underflow in the
(2,4) tree on the right:</p>

<p><img src="fig/GT-RBT-DB-remedy-case-2-1.jpg" alt="" /></p>

<p>… we do the following recoloring: the black node <em>y</em> is colored red, and the
double black node <em>r</em> is colored ordinary black:</p>

<p><img src="fig/GT-RBT-DB-remedy-case-2-2.jpg" alt="" /></p>

<p>The root of the above subtree takes on an extra black, which propagates only
if it was previously black and is not the root. If it was red it merely turns
black; if it was the root the extra black no longer affects the balanced black
height of the tree.</p>

<p><strong><em>Case 3:</em></strong> <em>y</em> is red: Perform a RBT <strong>adjustment</strong>, equivalent to choosing a different representation of a 3-node, after which either Case 1 or Case 2 applies.</p>

<p><img src="fig/GT-RBT-DB-remedy-case-3.jpg" alt="" /></p>

<p>These are both representations of the following 2-4 tree, but the
transformation allows one of the other cases to apply, reducing duplication of
cases.</p>

<p><img src="fig/GT-RBT-DB-remedy-case-3-2-4.jpg" alt="" /></p>

<p>The CLRS chapter divides the situation up into four cases: try to see whether
you can map between the above cases and theirs!</p>

<h4 id="time-complexity-of-rbt-deletion">Time Complexity of RBT Deletion</h4>

<p>The analysis is similar to the previous ones: Θ(lg <em>n</em>) search to find the
deletion point (the item to delete may be in an internal node, but we always
find its successor in any case, which is at the bottom of the tree), followed
by deletion and restructuring O(1) operations that are propagated at most up
O(lg <em>n</em>) levels. Deletion is <strong>Θ(lg <em>n</em>)</strong>.</p>

<h3 id="rbt-animations">RBT Animations</h3>

<p>You may want to look at these:</p>

<p><a href="http://secs.ceas.uc.edu/~franco/C321/html/RedBlack/redblack.html">http://secs.ceas.uc.edu/~franco/C321/html/RedBlack/redblack.html</a></p>

<pre><code>A java applet. You can go step by step and it tells you the rules violated and the fixes. Must click on "next step" until done with process. To delete, click on Delete and then on the node to be deleted. &lt;http://www.csanimated.com/animation.php?t=Red-black_tree&gt;

 A flash animation: slides with voice-over. It goes kind of fast (little time to figure out what property is being fixed in each case), and does not let you control slide by slide. 
</code></pre>

<hr />

<h2 id="related-data-structures">Related Data Structures</h2>

<p><strong>AVL Trees,</strong> named for their authors, are the oldest balanced trees. They are binary trees with the requirement that the heights of the left and right subtree of any given node differ at most by 1. A small amount of extra storage is needed to record height differences. Their operations are O(lg <em>n</em>) like RBTs, but may require O(lg <em>n</em>) rotations to rebalance. </p>

<p><strong>Splay Trees</strong> are binary trees in which an adjustment moving a node towards the root called <em>splaying</em> is done after every access (including search). There are no rules about properties to maintain and no labels. Amazingly, splaying alone is enough to guarantee O(lg <em>n</em>) behavior in an amortized sense: we will use these as an example when we cover chapter 17 Amortized analysis. They also make frequently accessed items more accessible. </p>

<p><strong>B-Trees,</strong> covered in Chapter 18 of Cormen et al. (but not in this course), are balanced multi-way trees that allow up to M keys per node for large M. They are used for trees in external (disk) storage, where speed is optimized by making the size of a node be the same as the size of a block read in by one disk read.</p>

<hr />

<h2 id="comparison-of-dictionary-implementations">Comparison of Dictionary Implementations</h2>

<p>First, here is a summary of the correspondence between (2,4) and Red-Black
tree operations:</p>

<table width="100%" border="1">
  <tr>
    <th colspan="3" scope="col"><div align="left">Insertion: Remedy double red</div></th>
  </tr>
  <tr>
    <th scope="row"><div align="left">(2,4) tree action</div></th>
    <td><div align="left"><strong>Red-Black Tree Action</strong></div></td>
    <td><div align="left"><strong>Result</strong></div></td>
  </tr>
  <tr>
    <td>Change of 4-node representation</td>
    <td>Restructuring</td>
    <td>Double red removed</td>
  </tr>
  <tr>
    <td>Split</td>
    <td>Recoloring</td>
    <td>Double red removed or propagated up</td>
  </tr>
  <tr>
    <th colspan="3" scope="row">&nbsp;</th>
  </tr>
  <tr>
    <th colspan="3" scope="row"><div align="left">Deletion: Remedy double black</div></th>
  </tr>
  <tr>
    <th scope="row"><div align="left">(2,4) tree action</div></th>
    <td><strong>Red-Black Tree Action</strong></td>
    <td><strong>Result</strong></td>
  </tr>
  <tr>
    <td>Transfer</td>
    <td>Restructuring</td>
    <td>Double black removed</td>
  </tr>
  <tr>
    <td>Fusion</td>
    <td>Recoloring</td>
    <td>Double black removed or propagated up</td>
  </tr>
  <tr>
    <td>Change of 3-node representation</td>
    <td>Adjustment</td>
    <td>Restructuring or recoloring follows</td>
  </tr>
</table>

<h3 id="a-comparison-of-run-times">A comparison of run times.</h3>

<table width="100%" border="1">
  <tr>
    <th scope="col">&nbsp;</th>
    <th scope="col">Search</th>
    <th scope="col">Insert</th>
    <th scope="col">Delete</th>
    <th scope="col">Notes</th>
  </tr>
  <tr>
    <th scope="row">Hash Table</th>
    <td>O(1) expected</td>
    <td>O(1) expected</td>
    <td>O(1) expected</td>
    <td><p>No ordered dictionary methods. Simple to implement.</p>
    </td>
  </tr>
  <tr>
    <th scope="row">Doubly Linked List</th>
    <td>O(<i>n</i>)</td>
    <td>O(1) if not sorted; O(<i>n</i>) if sorted </td>
    <td>&Theta;(1) if node given, O(<i>n</i>) otherwise</td>
    <td>Simple to implement.</td>
  </tr>
  <tr>
    <th scope="row">Skip List</th>
    <td>O(lg <i>n</i>) with high probability</td>
    <td>O(lg <i>n</i>) with high probability</td>
    <td>O(lg <i>n</i>) with high probability</td>
    <td>Randomized insertion. Simple to implement.</td>
  </tr>
  <tr>
    <th scope="row">Binary Tree</th>
    <td>O(<i>n</i>) worst case, O(lg <i>n</i>) random </td>
    <td>O(<i>n</i>) worst case, O(lg <i>n</i>) random </td>
    <td>O(<i>n</i>) worst case, O(lg <i>n</i>) random </td>
    <td>Moderately complex to implement deletion.</td>
  </tr>
  <tr>
    <th scope="row">Red-Black Tree</th>
    <td>O(lg <i>n</i>) worst case</td>
    <td>&Theta;(lg <i>n</i>)</td>
    <td>&Theta;(lg <i>n</i>) </td>
    <td>Complex to implement.</td>
  </tr>
</table>

<p>From this we can see that hash tables are most efficient expected behavior
when no ordered methods are needed, and red-black trees give us the best
guarantee when ordering matters.</p>

<hr />

<p>Dan Suthers Last modified: Mon Mar 3 20:13:52 HST 2014<br />
Images are from lecture slides provided by Michael Goodrich and Roberto
Tamassia, and from the instructor’s material for Cormen et al. Introduction to
Algorithms, Third Edition.  </p>


</div>



<div class="footer-background">
<footer>
  <div class="container page-footer">
    
      <p>Daniel Suthers | Information and Computer Sciences | University of Hawaii <br />
suthers@hawaii.edu</p>

    
    <p style="margin: 0">Powered by the <a href="http://morea-framework.github.io/">Morea Framework</a> (Theme: cerulean)<br>
       Last update on: <span>2014-06-19 07:00:29 -1000</span></p>
    <p style="margin: 0">
      25 modules
      
        | 27 outcomes
      
      
        | 143 readings
      
      
        | 36 experiences
      
      
    </p>
  </div>
</footer>
</div>
</body>
</html>

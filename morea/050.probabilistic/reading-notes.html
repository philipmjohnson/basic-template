<!DOCTYPE html>
<html>
<head>
  <title> Chapter 5 Notes | ICS 311 Spring 2014 </title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="utf-8">

  <!--  Load bootswatch-based Morea theme file. -->
  <link rel="stylesheet" href="/ics311s14/css/themes/cerulean/bootstrap.min.css">
  <link rel="stylesheet" href="/ics311s14/css/style.css">
  <link rel="stylesheet" href="/ics311s14/css/syntax.css">
  <link rel="shortcut icon" href="/ics311s14/favicon.ico" type="image/x-icon" />

  <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!--[if lt IE 9]>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.2/html5shiv.js"></script>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/respond.js/1.2.0/respond.js"></script>
  <![endif]-->

  <!-- Load Bootstrap JavaScript components -->
  <script src="http://code.jquery.com/jquery.min.js"></script>
  <script src="http://netdna.bootstrapcdn.com/bootstrap/3.1.0/js/bootstrap.min.js"></script>
</head>
<body>
<!-- Responsive navbar -->
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
        <!--  Display three horizontal lines when navbar collapsed. -->
        <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="#"> ICS 311 Spring 2014 </a>
    </div>
    <div class="collapse navbar-collapse">
      <ul class="nav navbar-nav">
        <li><a href="/ics311s14/index.html">Home</a></li>
	<li class="dropdown">
          <a class="dropdown-toggle" data-toggle="dropdown" href="#">Course Info<b class="caret"></b></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="/ics311s14/morea/010.introduction/reading-course-info.html">Overview</a></li>
              <li><a href="/ics311s14/morea/010.introduction/reading-policies.html">Policies</a></li>
              <li><a href="/ics311s14/morea/010.introduction/reading-topic-overview.html">Topics</a></li>
            </ul>
          </li>
        <li><a href="/ics311s14/modules/">Modules</a></li>
        
          <li><a href="/ics311s14/outcomes/">Outcomes</a></li>
        
        
          <li><a href="/ics311s14/readings/">Readings</a></li>
        
        
          <li><a href="/ics311s14/experiences/">Experiences</a></li>
        
        
        <li><a href="/ics311s14/news/">News</a></li>
      </ul>
    </div>
  </div>
</div>


<div class="container">
  <h2 id="outline">Outline</h2>

<ol>
  <li>Probabilistic Analysis</li>
  <li>Randomized Algorithms</li>
  <li>Skip Lists </li>
</ol>

<h2 id="motivations-and-preview">Motivations and Preview</h2>

<p>Instead of limiting analysis to best case or worst case, analyze all cases
based on a distribution of the probability of each case.</p>

<p>We implicitly used probabilistic analysis when we said that <em>given random
input</em> it takes n/2 comparisons <em>on average</em> to find an item in a linked list
of n items.</p>

<h3 id="hiring-problem-and-cost">Hiring Problem and Cost</h3>

<p>The book’s example is a little strange but illustrates the points well.
Suppose you are using an employment agency to hire an office assistant.</p>

<ul>
  <li>The agency sends you one candidate per day: interview and decide.</li>
  <li>Cost to interview is <em>c__i</em> per candidate (fee to agency). </li>
  <li>Cost to hire is <em>c__h</em> per candidate (includes firing prior assistant and fee to agency).</li>
  <li><em>ch</em> &gt; <em>ci</em></li>
  <li>
    <p>You always hire the best candidate seen so far.</p>

    <p>Hire-Assistant(n)
  1  best = 0                // fictional least qualified candidate
  2  for i = 1 to n
  3    interview candidate i // paying cost  <em>ci</em>
  4    if candidate i is better than candidate best
  5      best = i
  6      hire candidate i    // paying cost <em>ch</em></p>
  </li>
</ul>

<p>What is the cost of this strategy?</p>

<ul>
  <li>If we interview <em>n</em> candidates and hire <em>m</em> of them, cost is O(<em>cin</em> + <em>chm</em>)</li>
  <li>We interview all <em>n</em> and <em>ci</em> is small, so we focus on <em>chm</em>.</li>
  <li><em>chm</em> varies with each run and depends on interview order</li>
  <li>This is a common paradigm: finding the maximum or minimum in a sequence by examining each element, and changing the winner <em>m</em> times.</li>
</ul>

<h4 id="best-case">Best Case</h4>

<p>If each candidate is worse than all who came before, we hire one candidate:<br />
    O(<em>cin</em> + <em>ch</em>) = O(<em>cin</em>)</p>

<h4 id="worst-case">Worst Case</h4>

<p>If each candidate is better than all who came before, we hire all <em>n</em> (<em>m</em> =
<em>n</em>):<br />
    O(<em>cin</em> + <em>chn</em>) = O(<em>chn</em>) since <em>ch</em> &gt; <em>ci</em><br />
But this is pessimistic. What happens in the average case?</p>

<h3 id="probabilistic-analysis">Probabilistic Analysis</h3>

<ul>
  <li>We must know or make assumptions about the distribution of inputs.</li>
  <li>The expected cost is over this distribution.</li>
  <li>The analysis will give us <strong><em>average case</em></strong> running time.</li>
</ul>

<p>We don’t have this information for the Hiring Problem, but suppose we could
assume that candidates come in random order. Then the analysis can be done by
counting permutations:</p>

<ul>
  <li>Each ordering of candidates (relative to some reference ordering such as a ranking of the candidates) is equally likely to be any of the n! permutations of the candidates. </li>
  <li>In how many do we hire once? twice? three times? … <em>n</em>−1 times? <em>n</em> times?</li>
  <li>It depends on how many permutations have zero, one two … <em>n</em>−2 or <em>n</em>−1 candidates that come before a better candidate.</li>
  <li>This is complicated!</li>
  <li>Instead, we can do this analysis with indicator variables (next section)</li>
</ul>

<h3 id="randomized-algorithms">Randomized Algorithms</h3>

<p>We might not know the distribution of inputs or be able to model it.</p>

<p>Instead we <em>randomize</em> within the algorithm to <em>impose</em> a distribution on the
inputs.</p>

<p>An algorithm is <strong>randomized</strong> if its behavior is determined in parts by
values provided by a random number generator.</p>

<p>This requires a change in the hiring problem scenario:</p>

<ul>
  <li>The employment agency sends us a list of <em>n</em> candidates in advance and lets us choose the interview order.</li>
  <li>We choose randomly.</li>
</ul>

<p>Thus we <em>take control</em> of the question of whether the input is randomly
ordered: we <em>enforce</em> random order, so the average case becomes the <strong>_
expected value_</strong>.</p>

<hr />

<h2 id="probabilistic-analysis-with-indicator-random-variables">Probabilistic Analysis with Indicator Random Variables</h2>

<p>Here we introduce technique for computing the expected value of a random
variable, even when there is dependence between variables. Two informal
definitions will get us started:</p>

<p>A <strong>random variable</strong> (e.g., <em>X</em>) is a variable that takes on any of a range
of values according to a probability distribution.</p>

<p>The <strong>expected value</strong> of a random variable (e.g., E[<em>X</em>]) is the average
value we would observe if we sampled the random variable repeatedly.</p>

<h3 id="indicator-random-variables">Indicator Random Variables</h3>

<p>Given sample space <em>S</em> and event <em>A</em> in <em>S</em>, define the <strong>indicator random
variable</strong></p>

<p><img src="fig/indicator-random-variable.jpg" alt="" /></p>

<p>We will see that indicator random variables simplify analysis by letting us
work with the probability of the values of a random variable separately.</p>

<p><img src="fig/lemming.jpg" alt="" /></p>

<h4 id="lemma-1">Lemma 1</h4>

<p>For an event <em>A</em>, let <em>XA</em> = I{<em>A</em>}. Then the expected value <strong>E[<em>XA</em>] =
Pr{<em>A</em>}</strong> (the probability of event <em>A</em>).</p>

<p><em>Proof:</em> Let ¬<em>A</em> be the complement of <em>A</em>. Then</p>

<blockquote>
  <p>E[<em>XA</em>] = E[I{<em>A</em>}]   (by definition)<br />
    = 1<em>Pr{_A_} + 0</em>Pr{¬<em>A</em>}   (definition of expected value)<br />
    = Pr{<em>A</em>}. </p>
</blockquote>

<h3 id="simple-example">Simple Example</h3>

<p>What is the expected number of heads when flipping a fair coin once?</p>

<ul>
  <li>Sample space <em>S</em> is {H, T}</li>
  <li>Pr{H} = Pr{T} = 1/2</li>
  <li>Define indicator random variable _X_H= I{H}, which counts the number of heads in one flip.</li>
  <li>Since Pr{H} = 1/2, Lemma 1 says that E[_X_H] = 1/2. </li>
</ul>

<h3 id="less-simple-example">Less Simple Example</h3>

<p>What is the expected number of heads when we flip a fair coin <em>n</em> times?</p>

<p>Let <em>X</em> be a random variable for the number of heads in <em>n</em> flips.</p>

<p>We could compute E[<em>X</em>] = ∑<em>i</em>=0,<em>n__i</em> Pr{<em>X</em>=<em>i</em>} -- that is, compute and
add the probability of there being 0 heads total, 1 head total, 2 heads total
… n heads total, as is done in C.37 in the appendix and in my screencast
lecture <a href="http://youtu.be/MgnvWTZgqcA">5A</a> -- but it’s messy!</p>

<p>Instead use indicator random variables to count something we <em>do</em> know the
probability for: the probability of getting heads when flipping the coin once:</p>

<ul>
  <li>For <em>i = 1, 2, … n</em> define <em>Xi</em> = I{the _i_th flip results in event H}.</li>
  <li>Then <em>X</em> = ∑<em>i</em>=1,<em>n__Xi</em>.   _ (That is, count the flips individually and add them up.)_</li>
  <li>Lemma 1 says that E[<em>Xi</em>] = Pr{H} = 1/2 for <em>i = 1, 2, … n</em>.</li>
  <li>Expected number of heads is E[<em>X</em>] = E[∑<em>i</em>=1,<em>n__Xi</em>]</li>
  <li><em>Problem:</em> We don’t have ∑<em>i</em>=1,<em>n__Xi</em>; we only have E[<em>X_1], E[_X_2], … E[_Xn</em>].</li>
  <li><em>Solution:</em> <strong>Linearity of expectation</strong> (appendix C): <em><strong>expectation of sum equals sum of expectations.</strong></em> Therefore: <br />
<img src="fig/expected-value-n-flips.jpg" alt="" /></li>
</ul>

<p>The key idea: if it’s hard to count one way, use indicator random variables to
count an easier way!</p>

<h3 id="hiring-problem-revisited">Hiring Problem Revisited</h3>

<p>Assume that the candidates arrive in random order.</p>

<p>Let <em>X</em> be the random variable for the number of times we hire a new office
assistant.</p>

<p>Define indicator random variables <em>X_1, _X_2, … _Xn</em> where <em>Xi</em> =
I{candidate <em>i</em> is hired}.</p>

<p>We will rely on these properties:</p>

<ul>
  <li><em>X</em> = <em>X_1 + _X_2 + … + _Xn</em>   <em>(The total number of hires is the sum of whether we did each individual hire (1) or not (0).)</em></li>
  <li>Lemma 1 implies that E[<em>Xi</em>] = Pr{candidate <em>i</em> is hired}.</li>
</ul>

<p>We need to compute Pr{candidate <em>i</em> is hired}:</p>

<ul>
  <li>Candidate <em>i</em> is hired iff candidate <em>i</em> is better than candidates 1, 2, …, <em>i</em>−1</li>
  <li>Assumption of random order of arrival means any of the first <em>i</em> candidates are equally likely to be the best one so far. </li>
  <li>Thus, Pr{candidate <em>i</em> is the best so far} = 1/i. <br />
<em>(Intuitively, as you add more candidates each candidate is less and less
likely to be better than all the ones prior.)</em></li>
</ul>

<p>By Lemma 1, E[Xi] = <em>1/i</em>, a fact that lets us compute E[X]:<br />
<img src="fig/expected-value-hiring-problem.jpg" alt="" /></p>

<p>The sum is a harmonic series. From formula A7 in appendix A, the _n_th
<strong>harmonic number</strong> is:<br />
<img src="fig/A7-harmonic-number.jpg" alt="" /></p>

<p>Thus, the expected hiring cost is O(<em>ch</em> ln <em>n</em>), much better than worst case
O(<em>chn</em>)! (ln is the natural log. Formula 3.15 of the text can be used to show
that ln <em>n</em> = O(lg <em>n</em>.)</p>

<p>We will see this kind of analysis repeatedly. Its strengths are that it lets
us count in ways for which we have probabilities (compare to C.37), and that
it works even when there are dependencies between variables.</p>

<h3 id="expected-number-of-inversions">Expected Number of Inversions</h3>

<p>This is Exercise 5.2-5 page 122, for which there is a publicly posted
solution. This example shows the great utility of random variables.</p>

<p>Let A[1.. <em>n</em>] be an array of <em>n</em> distinct numbers. If <em>i &lt; j</em> and A[<em>i</em>] &gt;
A[<em>j</em>], then the pair (<em>i</em>, <em>j</em>) is called an <strong>inversion</strong> of A (they are
“out of order” with respect to each other). Suppose that the elements of A
form a uniform random permutation of ⟨1, 2, … <em>n</em>⟩.</p>

<p>We want to find the expected number of inversions. This has obvious
applications to analysis of sorting algorithms, as it is a measure of how much
a sequence is “out of order”. In fact, each iteration of the <code>while</code> loop in
insertion sort corresponds to the elimination of one inversion (see the posted
solution to problem 2-4c).</p>

<p><em>If we had to count in terms of whole permutations, figuring out how many
permutations had 0 inversions, how many had 1, … etc. (sound familiar? :),
that would be a real pain, as there are _n</em>! permutations of n items. Can
indicator random variables save us this pain by letting us count something
easier? _</p>

<p>We will count the number of inversions directly, without worrying about what
permutations they occur in:</p>

<p>Let <em>Xij</em>, <em>i &lt; j</em>, be an indicator random variable for the event where A[<em>i</em>] &gt; A[<em>j</em>] (they are inverted).</p>

<p>More precisely, define: X_ij<em>= I{A[_i</em>] &gt; A[<em>j</em>]} for 1 ≤ <em>i</em> &lt; <em>j</em> ≤ <em>n</em>.</p>

<p>Pr{X_ij_ = 1} = 1/2 because given two distinct random numbers the probability
that the first is bigger than the second is 1/2. <em>(We don’t care where they
are in a permutation; just that we can easily identify the probabililty that
they are out of order. Brilliant in its simplicity!)</em></p>

<p>By Lemma 1, E[X_ij_] = 1/2, and now we are ready to count.</p>

<p>Let X be the random variable denoting the total number of inverted pairs in
the array. X is the sum of all X_ij_ that meet the constraint 1 ≤ <em>i</em> &lt; <em>j</em> ≤
<em>n</em>:<br />
<img src="fig/inversions-random-var.jpg" alt="" /></p>

<p>We want the expected number of inverted pairs, so take the expectation of both
sides:<br />
<img src="fig/inversions-expected.jpg" alt="" /></p>

<p>Using linearity of expectation, we can simplify this far:<br />
<img src="fig/inversions-solution-a.jpg" alt="" /></p>

<p>The fact that our nested summation is choosing 2 things out of <em>n</em> lets us
write this as:<br />
<img src="fig/inversions-solution-b.jpg" alt="" /></p>

<p>We can use formula C.2 from the appendix:<br />
<img src="fig/C2-n-choose-k.jpg" alt="" /></p>

<p>In screencast <a href="http://youtu.be/MgnvWTZgqcA">5A</a> I show how to simplify this to
(<em>n</em>(<em>n</em>−1))/2, resulting in:</p>

<p><img src="fig/inversions-solution-c.jpg" alt="" /></p>

<p>Therefore the expected number of inverted pairs is <em>n</em>(<em>n</em> − 1)/4, or O(_n_2).</p>

<hr />

<h2 id="randomized-algorithms-1">Randomized Algorithms</h2>

<p><img src="fig/badguy.jpg" alt="" /></p>

<p>Above, we had to <em>assume</em> a distribution of inputs, but we may not have
control over inputs.</p>

<p>An “adversary” can always mess up our assumptions by giving us worst case
inputs. (This can be a fictional adversary in making analytic arguments, or it
can be a real one …)</p>

<p>Randomized algorithms foil the adversary by <em>imposing</em> a distribution of
inputs.</p>

<p>The modifiation to HIRE-ASSISTANT is trivial: add a line at the beginning that
randomizes the list of candidates.</p>

<ul>
  <li>The randomization is now in the algorithm, not the input distribution. </li>
  <li>Whereas before the algorithm was deterministic, and we could predict the hiring cost for a given input, now we can no longer say what the hiring cost will be.</li>
  <li>But our payoff is that no particular input elicits worst-case behavior, even what was worst-case for the deterministic version!</li>
  <li>Bad behavior occurs only if we get “unlucky” numbers. </li>
</ul>

<p>Having done so, the above analysis applies to give us <em>expected value</em> rather
than average case.</p>

<p><em>Discuss:</em> Summarize the difference between probabilistic analysis and
randomized algorithms.</p>

<h4 id="randomization-strategies">Randomization Strategies</h4>

<p>There are different ways to randomize algorithms. One way is to randomize the
ordering of the input before we apply the original algorithm (as was suggested
for HIRE-ASSISTANT above). A procedure for randomizing an array:</p>

<pre><code>  Randomize-In-Place(A)
  1  _n_ = A.length
  2  for _i_ = 1 to _n_
  3      swap A[_i_] with A[Random(_i_,_n_)]  
</code></pre>

<p>The text offers a proof that this produces a uniform random permutation. It is
obviously O(<em>n</em>).</p>

<p>Another approach to randomization is to randomize choices made within the
algorithm. This is the approach taken by Skip Lists …</p>

<hr />

<h2 id="skip-lists">Skip Lists</h2>

<p>This is additional material, not found in your textbook. I introduce Skip
Lists here for three reasons:</p>

<ol>
  <li>They are a natural extension of the linked list implementation of Dynamic Sets, which we covered recently.</li>
  <li>They are a good example of a randomized algorithm, where randomization is used to <em>improve</em> asymptotic behavior from O(<em>n</em>) to O(lg <em>n</em>).</li>
  <li>They are one candidate implementation to be tested in your homework, the Battle of the Dynamic Sets!</li>
</ol>

<p>Motivation: Why do we have to search the entire linked list one item at a
time? Can’t we be more efficient by diving into the middle somewhere?</p>

<p>Skip lists were first described by William Pugh. 1990. Skip lists: a
probabilistic alternative to balanced trees. Commun. ACM 33, 6 (June 1990),
668-676. DOI=10.1145/78973.78977 <a href="http://doi.acm.org/10.1145/78973.78977">http://doi.acm.org/10.1145/78973.78977</a> or
<a href="ftp://ftp.cs.umd.edu/pub/skipLists/skiplists.pdf">ftp://ftp.cs.umd.edu/pub/skipLists/skiplists.pdf</a> (actually he had a
conference paper the year before, but the CACM verion is more accessible).</p>

<p>My discussion below follows Goodrich &amp; Tamassia (1998), <em>Data Structures and
Algorithms in Java</em>, first edition, and uses images from their slides. Some
details differ from the edition 4 version of the text.</p>

<p>An animated applet may be found at
<a href="http://iamwww.unibe.ch/~wenger/DA/SkipList/">http://iamwww.unibe.ch/~wenger/DA/SkipList/</a>.</p>

<h3 id="definition-of-skip-list">Definition of Skip List</h3>

<p>Given a set <em>S</em> of items with distinct keys, a <strong>skip list</strong> is a series of
lists <em>S_0, _S_1, … _Sh</em> (as we shall see, <em>h</em> is the height) such that:</p>

<ul>
  <li>Each <em>S__i</em> contains the special keys −∞ and +∞</li>
  <li>List <em>S__h</em> contains only −∞ and +∞</li>
  <li>List <em>S_0 contains all of the keys of _S</em> in nondecreasing order. </li>
  <li>Each list is a subsequence of the previous one: <em>S_0 ⊇ _S_1 ⊇ … ⊇ _Sh</em>. 
<img src="fig/skip-list.jpg" alt="" /></li>
</ul>

<p>We can implement skip lists with nodes that have <code>above</code> and <code>below</code> fields as
well as the more familiar <code>prev</code> and <code>next</code>:</p>

<p><img src="fig/skip-list-node.jpg" alt="" /></p>

<h3 id="searching-a-skip-list">Searching a Skip List</h3>

<p>An algorithm for searching for a key <em>k</em> in a skip list as follows:</p>

<pre><code> SkipSearch(k)
   Input: search key k
   Output: Position p in S such that the item at p has the largest key ≤ k.
   Let p be the topmost-left position of S // _which has at least -∞ and +∞_
   while below(p) ≠ null do
       p = below(p)                       // _drop down_
       while key (next(p)) ≤ k do
           p = next(p)                    // _scan forward _
   return p. 
</code></pre>

<p>Example: Search for 78:</p>

<p><img src="fig/skip-list-search.jpg" alt="" /></p>

<h3 id="insertion-and-randomization">Insertion and Randomization</h3>

<p>Construction of a skip list is randomized:</p>

<ul>
  <li>Begin by inserting the new item where it belongs in S0</li>
  <li>After inserting an item at level Si, flip a coin to decide whether to also insert it at Si+1.</li>
  <li>If Si+1 does not exist, the height of the Skip lists can be increased. <br />
<em>(Alternatively, some policy can be used to limit growth as a function of n,
but the probability of a run of “heads” diminishes greatly as the number of
flips increases.).</em></li>
</ul>

<p>The psuedocode provided by Goodrich &amp; Tamassia uses a helper procedure
<code>InsertAfterAbove(p1, p2, k, d)</code> (left as exercise), which inserts key <code>k</code> and
data <code>d</code> after <code>p1</code> and above <code>p2</code>. (The following omits code for returning
“elements” not relevant here.)</p>

<pre><code> SkipInsert(k,d)
   Input: search key k and data d
   Instance Variables: s is the start node of the skip list,
     h is the height of the skip list, and n the number of entries 
   Output: None (list is modified to store d under k)
   p = SkipSearch(k)
   q = InsertAfterAbove(p, null, k, d)    // _we are at the bottom level_
   l = 0                                  // _keeps track of level we are at_ 
   while random(0,1) ≤ 1/2 do
       l = l + 1
       if l ≥ h then                      // need to add a level
           h = h + 1
           t = next(s)
           s = insertAfterAbove(null, s, −∞, null)
           insertAfterAbove(s, t +∞, null) 
       while above(p) == null do
           p = prev(p)                    // _scan backwards to find tower_
       p = above(p)                       // _jump higher_
       q = insertAfterAbove(p, q, k, d)   // _add new item to top of tower_
   n = n + 1.
</code></pre>

<p>For example, inserting key 15, when the randomization gave two “heads”,
forcing growth of <em>h</em> (for simplicity the figure does not include the above
and below pointers):</p>

<p><img src="fig/skip-list-insert.jpg" alt="" /></p>

<p>Deletion requires finding and removing all occurrences, and removing all but
one empty list if needed. Example for removing key 34:</p>

<p><img src="fig/skip-list-delete.jpg" alt="" /></p>

<h3 id="analysis">Analysis</h3>

<p>The <strong>worst case</strong> performance of skip lists is very bad, but highly unlikely.
Suppose <code>random(0,1)</code> is always less than 1/2. If there were no bound on the
height of the data structure, <code>SkipInsert</code> would never exit! But this is as
likely as an unending sequence of “heads” when flipping a fair coin.</p>

<p>If we do impose a bound <em>h</em> on the height of the list (<em>h</em> can be a function
of <em>n</em>), the worst case is that every item is inserted at every level. Then
searching, insertion and deletion is O(<em>n+h</em>): you not only have to search a
list S0 of <em>n</em> items, as with conventional linked lists; you also have to go
down <em>h</em> levels.</p>

<p>But the probabilistic analysis shows that the expected time is much better.
This requires that we find the expected value of the height <em>h</em>:</p>

<ul>
  <li>Probability that item is stored at level <em>i</em> is the probability of getting <em>i</em> consecutive heads: 1/2_i_.</li>
  <li>Probability P_i_ that level <em>i</em> has at least one item: P_i_ ≤ n/2_i_   <em>(We had n tries at getting i consecutive heads.)</em></li>
  <li>Probablity that <em>h</em> is larger than <em>i</em> is no more than P_i_.</li>
  <li>G&amp;T show that given a constant <em>c</em> &gt; 1, the probability that <em>h</em> is larger than <em>c</em> lg <em>n</em> is at most 1/<em>n__c</em>−1 (also worked out in screencast <a href="http://youtu.be/MgnvWTZgqcA">5A</a>).</li>
  <li>For example, for <em>c</em> = 3, the probability that <em>h</em> is larger than 3 lg <em>n</em> is at most 1/_n_2, which gets very small as n grows (e.g., p = .000001 = 1/1000000 for a list of length 1000).</li>
  <li>They conclude that the height <em>h</em> is O(lg <em>n</em>).</li>
</ul>

<p>The search time is proportional to the number of drop-down steps plus the
number of scan-forward steps. The number of drop-down steps is the same as <em>h</em>
or O(lg <em>n</em>). So, we need the number of scan-forward steps.</p>

<p>In their textbook (1998), G&amp;T provide this argument: Let <em>Xi</em> be the number of
keys examined scanning forward at level <em>i</em>.</p>

<p><img src="fig/code-SkipSearch.jpg" alt="" /></p>

<ul>
  <li>After the starting position, each key examined at level <em>i</em> cannot also belong to level <em>i+1</em>. <em>(Why?)</em></li>
  <li>Thus the probability that any key is counted in <em>Xi</em> is 1/2. <em>(Why??)</em></li>
  <li>Therefore the expected value of <em>Xi</em> is the expected number of times we must flip a coin before it comes up heads: 2.</li>
  <li>Hence the expected amount of time scanning forward at each level is O(1). <em>(Wow!)</em></li>
  <li>Since there are O(lg <em>n</em>) levels, the expected search time is O(lg <em>n</em>). </li>
</ul>

<p>In their slides (2002), they provide this alternative analysis of the number
of scan-forwards needed. The reasoning is very similar, but based on the odds
of the list we encounter being constructed:</p>

<ul>
  <li>When we scan forward in a list, the destination key does not belong to a higher list.</li>
  <li>Therefore, a scan forward is associated with a former coin toss that gave tails (otherwise it would be in the higher list).</li>
  <li>The expected number of coin tosses in order to get tails is 2.</li>
  <li>Therefore the expected number of scan-forward steps at each level is 2.</li>
  <li>Thus the total number of expected scan forward steps (summing across all <em>h</em> or O(lg <em>n</em>) levels) is O(lg <em>n</em>). </li>
</ul>

<p>A similar analysis can be applied to insertion and deletion. Thus, skip lists
are far superior to linked lists in performance.</p>

<p>G&amp;T also show that the expected space requirement is O(n). They leave as an
exercise the elimination of <code>above</code> and <code>prev</code> fields: if random(0,1) is
called up to <em>h</em> times in advance of the insertion search, then one can insert
the item “on the way down” as specified by the results.</p>

<hr />

<p>Dan Suthers Last modified: Tue Apr 15 16:40:33 HST 2014<br />
Images of mathematical expressions are from the instructor’s material for
Cormen et al. Introduction to Algorithms, Third Edition. Images of skip lists
are from lecture slides provided by M. Goodrich &amp; R. Tamassia.  </p>


</div>



<div class="footer-background">
<footer>
  <div class="container page-footer">
    
      <p>Daniel Suthers | Information and Computer Sciences | University of Hawaii <br />
suthers@hawaii.edu</p>

    
    <p style="margin: 0">Powered by the <a href="http://morea-framework.github.io/">Morea Framework</a> (Theme: cerulean)<br>
       Last update on: <span>2014-06-20 16:00:24 -1000</span></p>
    <p style="margin: 0">
      25 modules
      
        | 27 outcomes
      
      
        | 143 readings
      
      
        | 36 experiences
      
      
    </p>
  </div>
</footer>
</div>
</body>
</html>
